[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "vignettes/4_Visualization.html",
    "href": "vignettes/4_Visualization.html",
    "title": "Visualizing Data",
    "section": "",
    "text": "ggplot2 package simplifies the creation of plots using data frames. It offers a streamlined interface for defining variables to plot, configuring their display, and adjusting visual attributes. Consequently, adapting to changes in the data or transitioning between plot types requires only minimal modifications. This feature facilitates the creation of high-quality plots suitable for publication with minimal manual adjustments.\nggplot prefers data in the “long” format, where each dimension occupies a column and each observation corresponds to a row. Structuring data in this manner (discussed previously) enhances efficiency when generating figures with ggplot.\nWe will be using an extended version of the Metabric data set (from the assignment) in which columns have been added for the mRNA expression values for selected genes, including estrogen receptor alpha (ESR1), progesterone receptor (PGR), GATA3 and FOXA1.\n\nlibrary(tidyverse)\nmetabric &lt;- read_csv(\"data/metabric/clinical_and_expression_data.csv\")"
  },
  {
    "objectID": "vignettes/4_Visualization.html#overview",
    "href": "vignettes/4_Visualization.html#overview",
    "title": "Visualizing Data",
    "section": "",
    "text": "ggplot2 package simplifies the creation of plots using data frames. It offers a streamlined interface for defining variables to plot, configuring their display, and adjusting visual attributes. Consequently, adapting to changes in the data or transitioning between plot types requires only minimal modifications. This feature facilitates the creation of high-quality plots suitable for publication with minimal manual adjustments.\nggplot prefers data in the “long” format, where each dimension occupies a column and each observation corresponds to a row. Structuring data in this manner (discussed previously) enhances efficiency when generating figures with ggplot.\nWe will be using an extended version of the Metabric data set (from the assignment) in which columns have been added for the mRNA expression values for selected genes, including estrogen receptor alpha (ESR1), progesterone receptor (PGR), GATA3 and FOXA1.\n\nlibrary(tidyverse)\nmetabric &lt;- read_csv(\"data/metabric/clinical_and_expression_data.csv\")"
  },
  {
    "objectID": "vignettes/4_Visualization.html#building-a-basic-plot",
    "href": "vignettes/4_Visualization.html#building-a-basic-plot",
    "title": "Visualizing Data",
    "section": "Building a Basic Plot",
    "text": "Building a Basic Plot\nThe construction of ggplot graphics is incremental, allowing for the addition of new elements in layers. This approach grants users extensive flexibility and customization options, enabling the creation of tailored plots to suit specific needs.\n\nTo build a ggplot, any of the following basic templates can be used for different types of plots. My preferred choice is the one highlighted in pink, which will be consistently used in subsequent examples.\n Three things are required for a ggplot:\n\n1. The data\nWe first specify the data frame that contains the relevant data to create a plot. Here we are sending the metabric dataset to the ggplot() function.\n\n# render plot background\nmetabric |&gt; ggplot()\n\n\n\n\n\n\n\n\nThis command results in an empty gray panel. We must specify how various columns of the data frame should be depicted in the plot.\n\n\n2. Aesthetics aes()\nNext, we specify the columns in the data we want to map to visual properties (called aesthetics or aes in ggplot2). e.g. the columns for x values, y values and colours.\nSince we are interested in generating a scatter plot, each point will have an x and a y coordinate. Therefore, we need to specify the x-axis to represent the year and y-axis to represent the count.\n\nmetabric |&gt; ggplot(aes(x = GATA3, y = ESR1))\n\n\n\n\n\n\n\n\nThis results in a plot which includes the grid lines, the variables and the scales for x and y axes. However, the plot is empty or lacks data points.\n\n\n3. Geometric Representation geom_()\nFinally, we specify the type of plot (the geom). There are different types of geoms:\n\n\n\n\n\n\n\n\n\n\ngeom_blank() draws an empty plot.\n\n\n\n\n\n\n\n\n\ngeom_segment() draws a straight line. geom_vline() draws a vertical line and geom_hline() draws a horizontal line.\n\n\n\n\n\n\n\n\n\ngeom_curve() draws a curved line.\n\n\n\n\n\n\n\n\n\ngeom_line()/geom_path() makes a line plot. geom_line() connects points from left to right and geom_path() connects points in the order they appear in the data.\n\n\n\n\n\n\n\n\n\n\n\n\ngeom_point() produces a scatterplot.\n\n\n\n\n\n\n\n\n\ngeom_jitter() adds a small amount of random noise to the points in a scatter plot.\n\n\n\n\n\n\n\n\n\ngeom_dotplot() produces a dot plot.\n\n\n\n\n\n\n\n\n\ngeom_smooth() adds a smooth trend line to a plot.\n\n\n\n\n\n\n\n\n\ngeom_quantile() draws fitted quantile with lines (a scatter plot with regressed quantiles).\n\n\n\n\n\n\n\n\n\ngeom_density() creates a density plot.\n\n\n\n\n\n\n\n\n\n\n\n\ngeom_histogram() produces a histogram.\n\n\n\n\n\n\n\n\n\ngeom_bar() makes a bar chart. Height of the bar is proportional to the number of cases in each group.\n\n\n\n\n\n\n\n\n\ngeom_col() makes a bar chart. Height of the bar is proportional to the values in data.\n\n\n\n\n\n\n\n\n\n\n\n\ngeom_boxplot() produces a box plot.\n\n\n\n\n\n\n\n\n\ngeom_violin() creates a violin plot.\n\n\n\n\n\n\n\n\n\n\n\n\ngeom_ribbon() produces a ribbon (y interval defined line).\n\n\n\n\n\n\n\n\n\ngeom_area() draws an area plot, which is a line plot filled to the y-axis (filled lines).\n\n\n\n\n\n\n\n\n\ngeom_rect(), geom_tile() and geom_raster() draw rectangles.\n\n\n\n\n\n\n\n\n\ngeom_polygon() draws polygons, which are filled paths.\n\n\n\n\n\n\n\n\n\n\n\n\ngeom_text() adds text to a plot.\n\n\n\n\n\n\n\n\n\ngeom_text() adds label to a plot.\n\n\n\n\n\nThe range of geoms available in ggplot2 can be obtained by navigating to the ggplot2 package in the Packages tab pane in RStudio (bottom right-hand corner) and scrolling down the list of functions sorted alphabetically to the geom_... functions.\nSince we are interested in creating a scatter plot, the geometric representation of the data will be in point form. Therefore we use the geom_point() function.\nTo plot the expression of estrogen receptor alpha (ESR1) against that of the transcription factor, GATA3:\n\nmetabric |&gt; ggplot(aes(x = GATA3, y = ESR1)) + geom_point() \n\n\n\n\n\n\n\n\nNotice that we use the + sign to add a layer of points to the plot. This concept bears resemblance to Adobe Photoshop, where layers of images can be rearranged and edited independently. In ggplot, each layer is added over the plot in accordance with its position in the code using the + sign.\n\n\n\n\n\n\nA note about |&gt; and +\n\n\n\nggplot2 package was developed prior to the introduction of the pipe operator. In ggplot2, the + sign functions analogously to the pipe operator in other tidyverse functions, enabling code to be written from left to right."
  },
  {
    "objectID": "vignettes/4_Visualization.html#customizing-plots",
    "href": "vignettes/4_Visualization.html#customizing-plots",
    "title": "Visualizing Data",
    "section": "Customizing Plots",
    "text": "Customizing Plots\n\nAdding Colour\nThe above plot could be made more informative. For instance, the additional information regarding the ER status (i.e., ER_IHC column) could be incorporated into the plot. To do this, we can utilize aes() and specify which column in the metabric data frame should be represented as the color of the points.\n\nmetabric |&gt; ggplot(aes(x = GATA3, y = ESR1)) +\n  geom_point(aes(colour = ER_IHC)) \n\n\n\n\n\n\n\n\nNotice that we specify the colour = ER_IHC argument in the aes() mapping inside the geom_() function instead of ggplot() function. Aesthetic mappings can be set in both ggplot() and individual geom() layers and we will discuss the difference in the Section: Adding Layers.\nTo colour points based on a continuous variable, for example: Nottingham prognostic index (NPI):\n\nmetabric |&gt; ggplot(aes(x = GATA3, y = ESR1)) +\n  geom_point(aes(colour = NPI)) \n\n\n\n\n\n\n\n\nIn ggplot2, a color scale is used for continuous variables, while discrete or categorical values are represented using discrete colors.\nNote that some patient samples lack expression values, leading ggplot2 to remove those points with missing values for ESR1 and GATA3.\n\n\nAdding Shape\nLet’s add shape to points.\n\nmetabric |&gt; ggplot(aes(x = GATA3, y = ESR1)) + \n  geom_point(aes(shape = THREEGENE))\n\nWarning: Removed 209 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\n\n\nNote that some patient samples have not been classified and ggplot has removed those points with missing values for the three-gene classifier.\nSome aesthetics like shape can only be used with categorical variables:\n\nmetabric |&gt; ggplot() +\n  geom_point(aes(x = GATA3, y = ESR1, shape = SURVIVAL_TIME))\n\nError in `geom_point()`:\n! Problem while computing aesthetics.\nℹ Error occurred in the 1st layer.\nCaused by error in `scale_f()`:\n! A continuous variable cannot be mapped to the shape aesthetic\nℹ choose a different aesthetic or use `scale_shape_binned()`\n\n\nThe shape argument allows you to customize the appearance of all data points by assigning an integer associated with predefined shapes shown below:\n\n\n\n\n\nTo use asterix instead of points in the plot:\n\nmetabric |&gt; ggplot(aes(x = GATA3, y = ESR1)) + \n  geom_point(shape = 8)\n\n\n\n\n\n\n\n\nIt would be useful to be able to change the shape of all the points. We can do so by setting the size to a single value rather than mapping it to one of the variables in the data set - this has to be done outside the aesthetic mappings (i.e. outside the aes() bit) as above.\n\n\n\n\n\n\nAesthetic Setting vs. Mapping\n\n\n\nInstead of mapping an aesthetic property to a variable, you can set it to a single value by specifying it in the layer parameters (outside aes()). We map an aesthetic to a variable (e.g., aes(shape = THREEGENE)) or set it to a constant (e.g., shape = 8). If you want appearance to be governed by a variable in your data frame, put the specification inside aes(); if you want to override the default size or colour, put the value outside of aes().\n\n# size outside aes()\nmetabric |&gt; ggplot(aes(x = GATA3, y = ESR1)) +\n  geom_point(shape = 8)\n# size inside aes()\nmetabric |&gt; ggplot(aes(x = GATA3, y = ESR1)) +\n  geom_point(aes(shape = THREEGENE))\n\nWarning: Removed 209 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe above plots are created with similar code, but have rather different outputs. The first plot sets the size to a value and the second plot maps (not sets) the size to the three-gene classifier variable.\n\n\nIt is usually preferable to use colours to distinguish between different categories but sometimes colour and shape are used together when we want to show which group a data point belongs to in two different categorical variables.\n\nmetabric |&gt; ggplot(aes(x = GATA3, y = ESR1)) +\n  geom_point(aes(colour = CLAUDIN_SUBTYPE, shape = THREEGENE))\n\nWarning: Removed 209 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\n\n\n\n\nAdding Size and Transparency\nWe can adjust the size and/or transparency of the points.\nLet’s first increase the size of points.\n\nmetabric |&gt; ggplot(aes(x = GATA3, y = ESR1)) +\n  geom_point(aes(colour = CLAUDIN_SUBTYPE), size = 2)\n\n\n\n\n\n\n\n\nNote that here we add the size argument outside of the the aesthetic mapping.\nSize is not usually a good aesthetic to map to a variable and hence is not advised.\n\nmetabric |&gt; ggplot(aes(x = GATA3, y = ESR1)) +\n  geom_point(aes(colour = CLAUDIN_SUBTYPE, size = ER_IHC))\n\nWarning: Using size for a discrete variable is not advised.\n\n\n\n\n\n\n\n\n\nBecause this value is discrete, the default size scale uses evenly spaced sizes for points categorized on ER status.\nTransparency can be useful when we have a large number of points as we can more easily tell when points are overlaid, but like size, it is not usually mapped to a variable and sits outside the aes().\nLet’s change the transparency of points.\n\nmetabric |&gt; ggplot(aes(x = GATA3, y = ESR1)) +\n  geom_point(aes(colour = THREEGENE), alpha = 0.5) \n\n\n\n\n\n\n\n\n\n\nAdding Layers\nWe can add another layer to this plot using a different geometric representation (or geom_ function) we discussed previously.\nLet’s add trend lines to this plot using the geom_smooth() function which provide a summary of the data.\n\nmetabric |&gt; ggplot() +\n  geom_point(aes(x = GATA3, y = ESR1)) +\n  geom_smooth(aes(x = GATA3, y = ESR1))\n\n`geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\n\n\n\n\n\n\n\n\n\nNote that the shaded area surrounding blue line represents the standard error bounds on the fitted model.\nThere is some annoying duplication of code used to create this plot. We’ve repeated the exact same aesthetic mapping for both geoms. We can avoid this by putting the mappings in the ggplot() function instead.\n\nmetabric |&gt; ggplot(aes(x = GATA3, y = ESR1)) +\n  geom_point() +\n  geom_smooth()\n\n\n\n\n\n\n\n\nGeom layers specified earlier in the command are drawn first, preceding subsequent geom layers. The sequence of geom layers specified in the command determines their order of appearance in the plot.\nIf you switch the order of the geom_point() and geom_smooth() functions above, you’ll notice a change in the regression line. Specifically, the regression line will now be plotted underneath the points.\nLet’s make the plot look a bit prettier by reducing the size of the points and making them transparent. We’re not mapping size or alpha to any variables, just setting them to constant values, and we only want these settings to apply to the points, so we set them inside geom_point().\n\nmetabric |&gt; ggplot(aes(x = GATA3, y = ESR1)) +\n  geom_point(size = 0.5, alpha = 0.5) +\n  geom_smooth() \n\n`geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAesthetic Specifications in Plot vs. Layers\n\n\n\nAesthetic mappings can be provided either in the initial ggplot() call, in individual layers, or through a combination of both approaches. When there’s only one layer in the plot, the method used to specify aesthetics doesn’t impact the result.\n\n# colour argument inside ggplot()\nmetabric |&gt; ggplot(aes(x = GATA3, y = ESR1, colour = ER_IHC)) +\n  geom_point(size = 0.5, alpha = 0.5) +\n  geom_smooth() \n# colour argument inside geom_point()\nmetabric |&gt; ggplot(aes(x = GATA3, y = ESR1)) +\n  geom_point(aes(colour = ER_IHC), size = 0.5, alpha = 0.5) +\n  geom_smooth() \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn the left plot, since we specified the colour (i.e., colour = ER_IHC) inside the ggplot() function, the geom_smooth() function will fit regression lines for each type of ER status and will have coloured regression lines as shown above. This is because, when aesthetic mappings are defined in ggplot(), at the global level, they’re passed down to each of the subsequent geom layers of the plot.\nIf we want to add colour only to the points and fit a regression line across all points, we could specify the colour inside geom_point() function (i.e., right plot).\n\n\nSuppose you’ve spent a bit of time getting your scatter plot just right and decide to add another layer but you’re a bit worried about interfering with the code you so lovingly crafted, you can set the inherit.aes option to FALSE and set the aesthetic mappings explicitly for your new layer.\n\nmetabric |&gt; ggplot(aes(x = GATA3, y = ESR1, colour = ER_IHC)) +\n  geom_point(size = 0.5, alpha = 0.5) +\n  geom_smooth(aes(x = GATA3, y = ESR1), inherit.aes = FALSE)\n\n`geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\n\n\n\n\n\n\n\n\n\n\n\nCoordinate Space\nggplot automatically selects the scale and type of coordinate space for each axis. The majority of plots utilize Cartesian coordinate space, characterized by linear x and y scales.\nWe can change the axes limits as follows:\n\n# assign a variable to the plot\ngata_esrp &lt;- metabric |&gt; ggplot(aes(x = GATA3, y = ESR1)) +\n  geom_point(aes(colour = ER_IHC), size = 0.5, alpha = 0.5) +\n  geom_smooth() \n\n# change both x and y axes\ngata_esrp + lims(x = c(0, 13), y = c(0, 14))\n# change x axis\ngata_esrp + xlim(0, NA)  \n# change x axis\ngata_esrp + ylim(0, 13)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhen modifying the x-axis limit above, we assigned the upper limit as NA. You can leave one value as NA if you wish to calculate the corresponding limit from the range of the data.\nNotice that we assigned a variable named gata_esrp to our plot and modify it by adding labels. In ggplot, you have the flexibility to assign a variable to plot and then modify it by adding layers to the plot. This approach allows you to progressively build up your visualization, incorporating various elements to convey the desired information effectively.\n\n\n\n\n\n\nlims()/xlim()/ylim() vs. coord_cartesian()\n\n\n\nWhen you set the limits using any of the lims()/xlim()/ylim() functions, it discards all data points outside the specified range. Consequently, the regression line is computed across the remaining data points. In contrast, coord_cartesian() adjust limits without discarding the data, thus offering a visual zoom effect.\n\ngata_esrp + ylim(7, 10)\ngata_esrp + coord_cartesian(ylim = c(7, 10))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAxis Labels\nBy default, ggplot use the column names specified inside the aes() as the axis labels. We can change this using the xlab() and ylab() functions.\n\nmetabric |&gt; ggplot(aes(x = GATA3, y = ESR1)) +\n  geom_point(aes(colour = ER_IHC), size = 0.5, alpha = 0.5) +\n  geom_smooth() +\n  xlab(\"GATA3 Expression\") +\n  ylab(\"ESR1 Expression\")\n\n\n\n\n\n\n\n\n\n\nCustomizing Plots\nYou can customize plots to include a title, a subtitle, a caption or a tag.\nTo add a title and/or subtitle:\n\nmetabric |&gt; ggplot(aes(x = GATA3, y = ESR1)) +\n  geom_point(aes(colour = ER_IHC), size = 0.5, alpha = 0.5) +\n  geom_smooth() +\n  ggtitle(\n    label = \"Expression of estrogen receptor alpha against the transcription factor\",\n    subtitle = \"ESR1 vs GATA3\")\n\n\n\n\n\n\n\n\nWe can use the labs() function to add a title and additional information.\n\nmetabric |&gt; ggplot(aes(x = GATA3, y = ESR1)) +\n  geom_point(aes(colour = ER_IHC), size = 0.5, alpha = 0.5) +\n  geom_smooth() +\n  labs(\n    title = \"Expression of estrogen receptor alpha against the transcription factor\",\n    subtitle = \"ESR1 vs GATA3\",\n    caption = \"This is a caption\",\n    tag = \"Figure 1\",\n    y = \"ESR1 Expression\")\n\n\n\n\n\n\n\n\n\n\nThemes\nThemes control the overall appearance of the plot, including background color, grid lines, axis labels, and text styles. ggplot offers several built-in themes, and you can also create custom themes to match your preferences or the requirements of your publication. The default theme has a grey background.\n\ngata_esrp &lt;- metabric |&gt; ggplot(aes(x = GATA3, y = ESR1)) +\n  geom_point(aes(colour = ER_IHC), size = 0.5, alpha = 0.5) +\n  geom_smooth() \n\ngata_esrp + theme_bw()\n\n`geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\n\n\n\n\n\n\n\n\n\nTry these themes yourselves: theme_classic(), theme_dark(), theme_grey() (default), theme_light(), theme_linedraw(), theme_minimal(), theme_void() and theme_test().\n\n\nFacets\nTo enhance readability and clarity, we can break the above plot into sub-plots, called faceting. Facets are commonly used to split a plot into multiple panels based on the values of one or more variables. This can be useful for exploring relationships in the data across different subsets or categories.\nTo do this, we use the tilde symbol ~ to specify the column name that will form each facet.\n\nmetabric |&gt; ggplot(aes(x = GATA3, y = ESR1)) +\n  geom_point(aes(colour = PR_STATUS), size = 0.5, alpha = 0.5) +\n  geom_smooth() +\n  facet_wrap(~ PR_STATUS)\n\n`geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\n\n\n\n\n\n\n\n\n\nNote that the aesthetics and geoms including the regression line that were specified for the original plot, are applied to each of the facets.\nAlternatively, the variable(s) used for faceting can be specified using vars().\n\nmetabric |&gt; ggplot(aes(x = GATA3, y = ESR1)) +\n  geom_point(aes(colour = PR_STATUS), size = 0.5, alpha = 0.5) +\n  facet_wrap(vars(PR_STATUS))\n\n\n\n\n\n\n\n\nFaceting is usually better than displaying groups using different colours when there are more than two or three groups when it can be difficult to really tell which points belong to each group. A case in point is for the three-gene classification in the GATA3 vs ESR1 scatter plot we created above. Let’s create a faceted version of that plot.\n\nmetabric |&gt; ggplot(aes(x = GATA3, y = ESR1)) +\n  geom_point(aes(colour = THREEGENE), size = 0.5, alpha = 0.5) +\n  facet_wrap(vars(THREEGENE))\n\n\n\n\n\n\n\n\nThis helps explain why the function is called facet_wrap(). When it has too many subplots to fit across the page, it wraps around to another row. We can control how many rows or columns to use with the nrow and ncol arguments.\n\nmetabric |&gt; ggplot(aes(x = GATA3, y = ESR1)) +\n  geom_point(aes(colour = THREEGENE), size = 0.5, alpha = 0.5) +\n  facet_wrap(vars(THREEGENE), nrow = 1)\n\n\n\n\n\n\n\n\n\nmetabric |&gt; ggplot(aes(x = GATA3, y = ESR1)) +\n  geom_point(aes(colour = THREEGENE), size = 0.5, alpha = 0.5) +\n  facet_wrap(vars(THREEGENE), ncol = 2)\n\n\n\n\n\n\n\n\nWe can combine faceting on one variable with a colour aesthetic for another variable. For example, let’s show the tumour stage status (Neoplasm histologic grade) using faceting and the HER2 status using colours.\n\nmetabric |&gt; ggplot(aes(x = GATA3, y = ESR1, colour = HER2_STATUS)) +\n  geom_point(size = 0.5, alpha = 0.5) +\n  facet_wrap(vars(GRADE))\n\n\n\n\n\n\n\n\nInstead of this we could facet on more than variable.\n\nmetabric |&gt; ggplot(aes(x = GATA3, y = ESR1)) +\n  geom_point(size = 0.5, alpha = 0.5) +\n  facet_wrap(vars(GRADE, HER2_STATUS))\n\n\n\n\n\n\n\n\nFaceting on two variables is usually better done using the other faceting function, facet_grid(). Note the change in how the formula is written.\n\nmetabric |&gt; ggplot(aes(x = GATA3, y = ESR1)) +\n  geom_point(size = 0.5, alpha = 0.5) +\n  facet_grid(vars(GRADE), vars(HER2_STATUS))\n\n\n\n\n\n\n\n\nAgain we can use colour aesthetics alongside faceting to add further information to our visualization.\n\nmetabric |&gt; ggplot(aes(x = GATA3, y = ESR1, colour = CLAUDIN_SUBTYPE)) +\n  geom_point(size = 0.5, alpha = 0.5) +\n  facet_grid(vars(GRADE), vars(HER2_STATUS))\n\n\n\n\n\n\n\n\nFinally, we can use a labeller to change the labels for each of the categorical values so that these are more meaningful in the context of this plot.\n\ngrade_labels &lt;- c(\"1\" = \"Grade I\", \"2\" = \"Grade II\", \"3\" = \"Grade III\")\nher2_status_labels &lt;- c(\"Positive\" = \"HER2 positive\", \"Negative\" = \"HER2 negative\")\n#\nmetabric |&gt; ggplot(aes(x = GATA3, y = ESR1, colour = CLAUDIN_SUBTYPE)) +\n  geom_point(size = 0.5, alpha = 0.5) +\n  facet_grid(vars(GRADE),\n             vars(HER2_STATUS),\n             labeller = labeller(\n               GRADE = grade_labels,\n               HER2_STATUS = her2_status_labels\n              )\n            )\n\n\n\n\n\n\n\n\nThis would certainly be necessary if we were to use ER and HER2 status on one side of the grid.\n\ner_status_labels &lt;- c(\"Positive\" = \"ER positive\", \"Negative\" = \"ER negative\")\n#\nmetabric |&gt; ggplot(aes(x = GATA3, y = ESR1, colour = CLAUDIN_SUBTYPE)) +\n  geom_point(size = 0.5, alpha = 0.5) +\n  facet_grid(vars(GRADE),\n             vars(ER_IHC, HER2_STATUS),\n             labeller = labeller(\n               GRADE = grade_labels,\n               ER_IHC = er_status_labels,\n               HER2_STATUS = her2_status_labels\n              )\n            )"
  },
  {
    "objectID": "vignettes/4_Visualization.html#bar-chart",
    "href": "vignettes/4_Visualization.html#bar-chart",
    "title": "Visualizing Data",
    "section": "Bar chart",
    "text": "Bar chart\nThe metabric study redefined how we think about breast cancer by identifying and characterizing several new subtypes, referred to as integrative clusters. Let’s create a bar chart of the number of patients whose cancers fall within each subtype in the metabric cohort.\nThe geom_bar is the geom used to plot bar charts. It requires a single aesthetic mapping of the categorical variable of interest to x.\n\nmetabric |&gt; ggplot() +\n  geom_bar(aes(x = INTCLUST))\n\n\n\n\n\n\n\n\nThe dark grey bars are a big ugly - what if we want each bar to be a different colour?\n\nmetabric |&gt; ggplot() +\n  geom_bar(aes(x = INTCLUST, colour = INTCLUST))\n\n\n\n\n\n\n\n\nColouring the edges wasn’t quite what we had in mind. Look at the help for geom_bar to see what other aesthetic we should have used.\n\nmetabric |&gt; ggplot() +\n  geom_bar(aes(x = INTCLUST, fill = INTCLUST))\n\n\n\n\n\n\n\n\nWhat happens if we colour (fill) with something other than the integrative cluster?\n\nmetabric |&gt; ggplot() +\n  geom_bar(aes(x = INTCLUST, fill = ER_IHC))\n\n\n\n\n\n\n\n\nWe get a stacked bar plot.\nNote the similarity in what we did here to what we did with the scatter plot - there is a common grammar.\nLet’s try another stacked bar plot, this time with a categorical variable with more than two categories.\n\nmetabric |&gt; ggplot() +\n  geom_bar(aes(x = INTCLUST, fill = THREEGENE))\n\n\n\n\n\n\n\n\nWe can rearrange the three gene groups into adjacent (dodged) bars by specifying a different position within geom_bar():\n\nmetabric |&gt; ggplot() +\n  geom_bar(aes(x = INTCLUST, fill = THREEGENE), position = 'dodge')\n\n\n\n\n\n\n\n\nWhat if want all the bars to be the same colour but not dark grey, e.g. blue?\n\nmetabric |&gt; ggplot() +\n  geom_bar(aes(x = INTCLUST, fill = \"blue\"))\n\n\n\n\n\n\n\n\nThat doesn’t look right - why not?\nYou can set the aesthetics to a fixed value but this needs to be outside the mapping, just like we did before for size and transparency in the scatter plots.\n\nmetabric |&gt; ggplot() +\n  geom_bar(aes(x = INTCLUST), fill = \"blue\")\n\n\n\n\n\n\n\n\nSetting this inside the aes() mapping told ggplot2 to map the colour aesthetic to some variable in the data frame, one that doesn’t really exist but which is created on-the-fly with a value of “blue” for every observation.\n\n\n\n\n\n\nExpand To Learn About Statistical transformations\n\n\n\n\n\nYou may have noticed that ggplot2 didn’t just plot values from our data set but had to do some calculation first for the bar chart, i.e. it had to sum the number of observations in each category.\nEach geom has a statistical transformation. In the case of the scatter plot, geom_point uses the “identity” transformation which means just use the values as they are (i.e. not really a transformation at all). The statistical transformation for geom_bar is “count”, which means it will count the number of observations for each category in the variable mapped to the x aesthetic.\nYou can see which statistical transformation is being used by a geom by looking at the stat argument in the help page for that geom.\nThere are some circumstances where you’d want to change the stat, for example if we already had count values in our table.\n\n# the previous plot\nmetabric |&gt; ggplot() +\n  geom_bar(aes(x = INTCLUST))\n# same plot after computing counts and using the identity stat\ncounts &lt;- metabric |&gt; count(INTCLUST) \ncounts |&gt; ggplot() +\n  geom_bar(aes(x = INTCLUST, y = n), stat = \"identity\")"
  },
  {
    "objectID": "vignettes/4_Visualization.html#box-plot",
    "href": "vignettes/4_Visualization.html#box-plot",
    "title": "Visualizing Data",
    "section": "Box plot",
    "text": "Box plot\nBox plots (or box & whisker plots) are a particular favourite seen in many seminars and papers. Box plots summarize the distribution of a set of values by displaying the minimum and maximum values, the median (i.e. middle-ranked value), and the range of the middle 50% of values (inter-quartile range). The whisker line extending above and below the IQR box define Q3 + (1.5 x IQR), and Q1 - (1.5 x IQR) respectively.\n To create a box plot from Metabric dataset:\n\nmetabric |&gt; ggplot(aes(x = ER_IHC, y = GATA3)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\nSee geom_boxplot help to explain how the box and whiskers are constructed and how it decides which points are outliers and should be displayed as points.\nHow about adding another layer to display all the points?\n\nmetabric |&gt; ggplot(aes(x = ER_IHC, y = GATA3)) +\n  geom_boxplot() +\n  geom_point()\n\n\n\n\n\n\n\n\nIdeally, we’d like these points to be spread out a bit. The help page of geom_point fucntion points to geom_jitter as more suitable when one of the variables is categorical.\n\nmetabric |&gt; ggplot(aes(x = ER_IHC, y = GATA3)) +\n  geom_boxplot() +\n  geom_jitter()\n\n\n\n\n\n\n\n\nWell, that’s a bit of a mess. We can bring the geom_boxplot() layer forward:\n\nmetabric |&gt; ggplot(aes(x = ER_IHC, y = GATA3)) +\n  geom_jitter() +\n  geom_boxplot(alpha = 0.5) \n\n\n\n\n\n\n\n\nStill not the best plot. We can reduce the spread or jitter and make the points smaller and transparent:\n\nmetabric |&gt; ggplot(aes(x = ER_IHC, y = GATA3)) +\n  geom_boxplot() +\n  geom_jitter(width = 0.3, size = 0.5, alpha = 0.25)\n\n\n\n\n\n\n\n\nDisplaying points in this way makes much more sense when we only have a few observations and where the box plot masks the fact, perhaps giving the false impression that the sample size is larger than it actually is. Here it makes less sense as we have very many observations.\nLet’s try a colour aesthetic to also look at how estrogen receptor expression differs between HER2 positive and negative tumours.\n\nmetabric |&gt; ggplot(aes(x = ER_IHC, y = GATA3, colour = HER2_STATUS)) +\n  geom_boxplot()"
  },
  {
    "objectID": "vignettes/4_Visualization.html#violin-plot",
    "href": "vignettes/4_Visualization.html#violin-plot",
    "title": "Visualizing Data",
    "section": "Violin plot",
    "text": "Violin plot\nA violin plot is used to visualize the distribution of a numeric variable across different categories. It combines aspects of a box plot and a kernel density plot.\nThe width of the violin at any given point represents the density of data at that point. Wider sections indicate a higher density of data points, while narrower sections indicate lower density. By default, violin plots are symmetric.\n\nmetabric |&gt; ggplot(aes(y = GATA3, x = ER_IHC, colour = HER2_STATUS)) + \n  geom_violin()\n\n\n\n\n\n\n\n\nInside each violin plot, a box plot is often included, showing additional summary statistics such as the median, quartiles, and potential outliers. This helps provide a quick overview of the central tendency and spread of the data within each category.\n\nmetabric |&gt; ggplot(aes(y = GATA3, x = ER_IHC, colour = HER2_STATUS)) + \n  geom_violin() + \n  geom_boxplot(width = 0.8, alpha = 0.4)\n\n\n\n\n\n\n\n\nIn the above plot, the violin plots and box plots are misaligned. You can read the cause of this here.\nTo align them, we can use the position_dodge() function to manually adjusting the horizontal position as follows.\n\nmetabric |&gt; ggplot(aes(y = GATA3, x = ER_IHC, colour = HER2_STATUS)) + \n  geom_violin(position = position_dodge(0.8)) + \n  geom_boxplot(width = 0.8, alpha = 0.4)"
  },
  {
    "objectID": "vignettes/4_Visualization.html#histogram",
    "href": "vignettes/4_Visualization.html#histogram",
    "title": "Visualizing Data",
    "section": "Histogram",
    "text": "Histogram\nThe geom for creating histograms is, rather unsurprisingly, geom_histogram().\n\nmetabric |&gt; ggplot() +\n  geom_histogram(aes(x = AGE_AT_DIAGNOSIS))\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\nThe warning message hints at picking a more optimal number of bins by specifying the binwidth argument.\n\nmetabric |&gt; ggplot() +\n  geom_histogram(aes(x = AGE_AT_DIAGNOSIS), binwidth = 5)\n\n\n\n\n\n\n\n\nOr we can set the number of bins.\n\nmetabric |&gt; ggplot() +\n  geom_histogram(aes(x = AGE_AT_DIAGNOSIS), bins = 20)\n\n\n\n\n\n\n\n\nThese histograms are not very pleasing, aesthetically speaking - how about some better aesthetics?\n\nmetabric |&gt; ggplot() +\n  geom_histogram(\n    aes(x = AGE_AT_DIAGNOSIS), \n    bins = 20, \n    colour = \"darkblue\", \n    fill = \"grey\")"
  },
  {
    "objectID": "vignettes/4_Visualization.html#density-plot",
    "href": "vignettes/4_Visualization.html#density-plot",
    "title": "Visualizing Data",
    "section": "Density plot",
    "text": "Density plot\nDensity plots are used to visualize the distribution of a continuous variable in a dataset. These are essentially smoothed histograms, where the area under the curve for each sub-group will sum to 1. This allows us to compare sub-groups of different size.\n\nmetabric |&gt; ggplot() + \n  geom_density(aes(x = AGE_AT_DIAGNOSIS, colour = INTCLUST))"
  },
  {
    "objectID": "vignettes/4_Visualization.html#categorical-variables-factors",
    "href": "vignettes/4_Visualization.html#categorical-variables-factors",
    "title": "Visualizing Data",
    "section": "Categorical variables – factors",
    "text": "Categorical variables – factors\nSeveral of the variables in the Metabric data set are categorical. Some of these have been read into R as character types (e.g. the three gene classifier), other as numerical values (e.g. tumour stage). We also have some binary variables that are essentially categorical variables but with only 2 possible values (e.g. ER status).\nIn many of the plots given above, ggplot2 has treated character variables as categorical in situations where a categorical variable is expected. For example, when we displayed points on a scatter plot using different colours for each three gene classification, or when we created separate box plots in the same graph for ER positive and negative patients.\nBut what about when our categorical variable has been read into R as a continuous variable, e.g. Tumour_stage, which is read in as a double type.\n\nmetabric |&gt; ggplot() +\n  geom_point(aes(x = GATA3, y = ESR1, colour = TUMOR_STAGE))\n\n\n\n\n\n\n\n\n\ntable(metabric$TUMOR_STAGE)\n\n\n  0   1   2   3   4 \n  4 490 818 118  10 \n\n\nTumour stage has only 5 discrete states but ggplot2 doesn’t know these are supposed to be a restricted set of values and has used a colour scale to show them as if they were continuous. We need to tell R that these are categorical (or factors).\nLet’s convert our tumour stage variable to a factor using the as.factor() function.\n\nmetabric$TUMOR_STAGE &lt;- as.factor(metabric$TUMOR_STAGE)\nmetabric |&gt; select(PATIENT_ID, TUMOR_STAGE) |&gt; head()\n\n# A tibble: 6 × 2\n  PATIENT_ID TUMOR_STAGE\n  &lt;chr&gt;      &lt;fct&gt;      \n1 MB-0000    2          \n2 MB-0002    1          \n3 MB-0005    2          \n4 MB-0006    2          \n5 MB-0008    2          \n6 MB-0010    4          \n\n\nR actually stores categorical variables as integers but with some additional metadata about which of the integer values, or ‘levels’, corresponds to each category.\n\ntypeof(metabric$TUMOR_STAGE)\n\n[1] \"integer\"\n\nclass(metabric$TUMOR_STAGE)\n\n[1] \"factor\"\n\nlevels(metabric$TUMOR_STAGE)\n\n[1] \"0\" \"1\" \"2\" \"3\" \"4\"\n\n\n\nmetabric |&gt; ggplot() +\n  geom_point(aes(x = GATA3, y = ESR1, colour = TUMOR_STAGE))\n\n\n\n\n\n\n\n\nIn this case the order of the levels makes sense but for other variables you may wish for more control over the ordering. Take the integrative cluster variable for example. We created a bar plot of the numbers of patients in the Metabric cohort within each integrative cluster. Did you notice the ordering of the clusters? 10 came just after 1 and before 2. That looked a bit odd as we’d have naturally expected it to come last of all. R, on the other hand, is treating this vector as a character vector (mainly because of the ‘ER-’ and ‘ER+’ subtypes of cluster 4, and sorts the values into alphanumerical order.\n\nmetabric$INTCLUST &lt;- as.factor(metabric$INTCLUST)\nlevels(metabric$INTCLUST)\n\n [1] \"1\"    \"10\"   \"2\"    \"3\"    \"4ER+\" \"4ER-\" \"5\"    \"6\"    \"7\"    \"8\"   \n[11] \"9\"   \n\n\nAs discussed Section: Factors, we can create a factor using the factor() function and specify the levels using the levels argument.\n\nmetabric$INTCLUST &lt;- factor(metabric$INTCLUST, levels = c(\"1\", \"2\", \"3\", \"4ER-\", \"4ER+\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\"))\nlevels(metabric$INTCLUST)\n\n [1] \"1\"    \"2\"    \"3\"    \"4ER-\" \"4ER+\" \"5\"    \"6\"    \"7\"    \"8\"    \"9\"   \n[11] \"10\"  \n\n\n\nmetabric |&gt; ggplot() +\n  geom_bar(aes(x = INTCLUST, fill = INTCLUST))\n\n\n\n\n\n\n\n\n\nLine plot\nA line plot is used to display the trend or pattern in data over a continuous range of values, typically along the x-axis (horizontal axis).\nBefore we create a line plot, let’s start by reading a subset of cancer_mort dataset using the read_csv() function:\n\nlibrary(tidyverse)\n# first read the dataset\ncancer_mort_full &lt;- read_csv(\"data/Australian_Cancer_Incidence_and_Mortality.csv\")  \n# lets consider the rows with cancer types that starts with B letters only. \n# this is done for illustartion purposes. \ncancer_mort &lt;- cancer_mort_full |&gt; filter(str_detect(Cancer_Type, '^B[a-z]+'))\n\nNext, we filter the cancer_mort data frame to plot only the counts for the female patients in the age group 55-59 and are categorized as moratality cases.\n\n# define a new subset from cancer_mort dataset\ncancer_mort_55 &lt;- cancer_mort |&gt; \n  filter(Age == '55-59' & Type == \"Mortality\", Sex == 'Female')\n\n\ncancer_mort_55 |&gt; ggplot(aes(x = Year, y = Count)) + \n  geom_line(aes(colour = Cancer_Type)) \n\n\n\n\n\n\n\n\nAnother aesthetic available for geom_line is linetype.\n\ncancer_mort_55 |&gt; ggplot(aes(x = Year, y = Count)) + \n  geom_line(aes(linetype = Cancer_Type))"
  },
  {
    "objectID": "vignettes/4_Visualization.html#saving-plot-images",
    "href": "vignettes/4_Visualization.html#saving-plot-images",
    "title": "Visualizing Data",
    "section": "Saving plot images",
    "text": "Saving plot images\nUse ggsave() to save the last plot you displayed.\n\nggsave(\"integrative_cluster.png\")\n\nYou can alter the width and height of the plot and can change the image file type.\n\nggsave(\"integrative_cluster.pdf\", width = 20, height = 12, units = \"cm\")\n\nYou can also pass in a plot object you have created instead of using the last plot displayed. See the help page (?ggsave) for more details."
  },
  {
    "objectID": "vignettes/1_Introduction.html",
    "href": "vignettes/1_Introduction.html",
    "title": "Basics of R Programming Language",
    "section": "",
    "text": "R is a powerful programming language and open-source software widely used for statistical computing and data analysis. This programming language is developed by Ross Ihaka and Robert Gentleman at the University of Auckland, New Zealand. R has gained popularity among statisticians, data scientists, researchers, and analysts for its flexibility, extensibility, and robust statistical capabilities."
  },
  {
    "objectID": "vignettes/1_Introduction.html#r",
    "href": "vignettes/1_Introduction.html#r",
    "title": "Basics of R Programming Language",
    "section": "",
    "text": "R is a powerful programming language and open-source software widely used for statistical computing and data analysis. This programming language is developed by Ross Ihaka and Robert Gentleman at the University of Auckland, New Zealand. R has gained popularity among statisticians, data scientists, researchers, and analysts for its flexibility, extensibility, and robust statistical capabilities."
  },
  {
    "objectID": "vignettes/1_Introduction.html#why-learn-r",
    "href": "vignettes/1_Introduction.html#why-learn-r",
    "title": "Basics of R Programming Language",
    "section": "Why learn R?",
    "text": "Why learn R?\nHere are several compelling reasons to consider learning R:\n\nStatistical Analysis\nData Visualization\nOpen Source\nCommunity Support\nExtensibility\nIntegration with Other Languages\nData Science and Machine Learning\nWidely Used in Academia and Industry\nContinuous Development\n\n\nR vs Python\n\nR and Python are the two most popular programming languages used by data analysts and data scientists. Both are free and open source.\nPython is a general-purpose programming language, while R is a statistical programming language."
  },
  {
    "objectID": "vignettes/1_Introduction.html#getting-started-with-r",
    "href": "vignettes/1_Introduction.html#getting-started-with-r",
    "title": "Basics of R Programming Language",
    "section": "Getting Started with R",
    "text": "Getting Started with R\nTo begin working with R, users typically install an Integrated Development Environment (IDE) such as RStudio, which provides a user-friendly interface for coding, debugging, and visualizing results. R scripts are written in the R language and can be executed interactively or saved for later use."
  },
  {
    "objectID": "vignettes/1_Introduction.html#a-look-around-rstudio",
    "href": "vignettes/1_Introduction.html#a-look-around-rstudio",
    "title": "Basics of R Programming Language",
    "section": "A look around RStudio",
    "text": "A look around RStudio\nOpen RStudio. You will see four windows (aka panes). Each window has a different function. The screenshot below shows an analogy linking the different RStudio windows to cooking.\n\n\n\n\n\n\nConsole Pane\n\n\n\n\n\nOn the left-hand side, you’ll find the console. This is where you can input commands (code that R can interpret), and the responses to your commands, known as output, are displayed here. While the console is handy for experimenting with code, it doesn’t save any of your entered commands. Therefore, relying exclusively on the console is not recommended.\n\n\nHistory Pane\n\n\n\n\n\nThe history pane (located in the top right window) maintains a record of the commands that you have executed in the R console during your current R session. This includes both correct and incorrect commands.\nYou can navigate through your command history using the up and down arrow keys in the console. This allows you to quickly recall and re-run previous commands without retyping them.\n\n\nEnvironment Pane\n\n\n\n\n\nThe environment pane (located in the top right window) provides an overview of the objects (variables, data frames, etc.) that currently exist in your R session. It displays the names, types, dimensions, and some content of these objects. This allows you to monitor the state of your workspace in real-time.\n\n\nPlotting Pane\n\n\n\n\n\nThe plotting pane (located in the bottom right window) is where graphical output, such as plots and charts, is displayed when you create visualizations in R. The Plotting pane often includes tools for zooming, panning, and exporting plots, providing additional functionality for exploring and customizing your visualizations.\n\n\nHelp Pane\n\n\n\n\n\nThe help pane (located in the bottom right window) is a valuable resource for accessing documentation and information about R functions, packages, and commands. When you type a function or command in the console and press the F1 key (Mac: fn + F1) the Help pane displays relevant documentation. Additionally, you can type a keyword in the text box at the top right corner of the Help Pane.\n\n\nFiles Pane\n\n\n\n\n\nThe files pane provides a file browser and file management interface within RStudio. It allows you to navigate through your project directories, view files, and manage your file system.\n\n\nPackages Pane\n\n\n\n\n\nThis pane provides a user-friendly interface for managing R packages. It lists installed packages and allows you to load, unload, update, and install packages.\n\n\nViewer Pane\n\n\n\n\n\nIt is used to display dynamic content generated by R, such as HTML, Shiny applications, or interactive visualizations."
  },
  {
    "objectID": "vignettes/1_Introduction.html#working-directory",
    "href": "vignettes/1_Introduction.html#working-directory",
    "title": "Basics of R Programming Language",
    "section": "Working directory",
    "text": "Working directory\nOpening an RStudio session launches it from a specific location. This is the working directory. R looks in the working directory by default to read in data and save files. You can find out what the working directory is by using the command getwd(). This shows you the path to your working directory in the console. In Mac this is in the format /path/to/working/directory and in Windows C:\\path\\to\\working\\directory. It is often useful to have your data and R scripts in the same directory and set this as your working directory. We will do this now.\nMake a folder for this course somewhere on your computer that you will be able to easily find. Name the folder for example, Intro_R_course. Then, to set this folder as your working directory:\nIn RStudio click on the Files tab and then click on the three dots, as shown below.\n\n\n\n\n\nIn the window that appears, find the folder you created (e.g. Intro_R_course), click on it, then click Open. The files tab will now show the contents of your new folder. Click on More → Set As Working Directory, as shown below.\n\n\n\n\n\nNote: You can use an RStudio project as described here to automatically keep track of and set the working directory."
  },
  {
    "objectID": "vignettes/1_Introduction.html#r-scripts",
    "href": "vignettes/1_Introduction.html#r-scripts",
    "title": "Basics of R Programming Language",
    "section": "R Scripts",
    "text": "R Scripts\nIn RStudio, the Script pane (located at the top left window) serves as a dedicated space for writing, editing, and executing R scripts. It is where you compose and organize your R code, making it an essential area for creating reproducible and well-documented analyses.\nRStudio provides syntax highlighting in the Script pane, making it easier to identify different components of your code. You can execute individual lines or selections of code from the Script pane. This helps in testing and debugging code without running the entire script.\n\nOpen a New R Script\nNavigate to File → New File → R Script, a new pane will emerge in the top-left corner. Save this blank text file as ‘Week_1_tidyverse.R’ in your current working directory (e.g. Intro_R_course)."
  },
  {
    "objectID": "vignettes/1_Introduction.html#comments",
    "href": "vignettes/1_Introduction.html#comments",
    "title": "Basics of R Programming Language",
    "section": "Comments",
    "text": "Comments\nIn R, any text following the hash symbol # is termed a comment. R disregards this text, considering it non-executable. Comments serve the purpose of documenting your code, aiding your future understanding of specific lines, and highlighting the intentions or challenges encountered.\nRStudio makes it easy to comment or uncomment a paragraph: Select the lines you want to comment (to comment a set of lines) or placing the cursor at any location of a line (to comment a single line), press at the same time on your keyboard ⌘ + Shift + C (mac) or Ctrl + Shift + C (Windows/Linux).\nExtensive use of comments is encouraged throughout this course.\n\n# This is a comment. Ignored by R. But useful for me!"
  },
  {
    "objectID": "vignettes/1_Introduction.html#executing-commands",
    "href": "vignettes/1_Introduction.html#executing-commands",
    "title": "Basics of R Programming Language",
    "section": "Executing Commands",
    "text": "Executing Commands\nExecuting commands or running code is the process of submitting a command to your computer, which does some computation and returns an answer. In RStudio, there are several ways to execute commands:\n\nSelect the line(s) of code using the mouse, and then click Run at the top right corner of the R text file.\nSelect Run Lines from the Code menu.\nClick anywhere on the line of code and click Run.\nSelect the line(s) you want to run. Press ⌘ + Return (Mac) or Ctrl + Enter (Windows/Linux) to run the selected code.\n\nWe suggest the third option, which is fastest. This link provides a list of useful RStudio keyboard shortcuts that can be beneficial when coding and navigating the RStudio IDE.\nWhen you type in, and then run the commands shown in the grey boxes below, you should see the result in the Console pane at bottom left.\n\nSimple Maths in R\nWe can use R as a calculator to do simple maths.\n\n3 + 5\n\n[1] 8\n\n\nMore complex calculator functions are built in to R, which is the reason it is popular among mathematicians and statisticians. To use these functions, we need to call these functions.\n\n\nCalling Functions\nR has a large collection of built-in functions that are called like this:\n\nfunction_name(argument1 = value1, argument2 = value2, ...)\n\nLet’s explore using seq() function to create a series of numbers.\nStart by typing se and then press Tab. RStudio will suggest possible completions. Specify seq() by typing more or use the up/down arrows to select it. You’ll see a helpful tooltip-type information pop up, reminding you of the function’s arguments. If you need more assistance, press F1 (Windows/linux) or fn + Tab (Mac) to access the full documentation in the help tab at the lower right.\nNow, type the arguments 1, 10 and press &lt;kbd&lt;Enter.\n\nseq(1, 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nYou can explicitly specify arguments using the name = value format. However, if you don’t, R will try to resolve them based on their position.\n\nseq(from = 1, to = 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nIn this example, it assumes that we want a sequence starting from 1 and ending at 10. Since we didn’t mention the step size, it defaults to the value defined in the function, which is 1 in this case.\n\nseq(from = 1, to = 10, by = 2)\n\n[1] 1 3 5 7 9\n\n\nIf you are using name = value format the order of the arguments does not matter.\n\nseq(to = 10, by = 2, from = 1)\n\n[1] 1 3 5 7 9\n\n\nFor frequently used functions, I might rely on positional resolution for the first one or two arguments. However, beyond that, I prefer to use the name = value format for clarity and precision.\nTo take the log of 100:\n\nlog(x = 100, base = 10)\n\n[1] 2\n\n\nTo take the square root of 100:\n\nsqrt(100) # this is the short-hand of sqrt(x = 100)\n\n[1] 10\n\n\nNotice that the square root function is abbreviated to sqrt(). This is to make writing R code faster, however the draw back is that some functions are hard to remember, or to interpret."
  },
  {
    "objectID": "vignettes/1_Introduction.html#getting-help",
    "href": "vignettes/1_Introduction.html#getting-help",
    "title": "Basics of R Programming Language",
    "section": "Getting Help",
    "text": "Getting Help\nIn R, the ? and ?? operators are used for accessing help documentation, but they behave slightly differently.\n\nThe ? operator is used to access help documentation for a specific function or topic. When you type ? followed by the name of a function, you get detailed information about that function. For example try:\n\n\n?mean\n\n\nView Output\n\n&lt;!DOCTYPE html&gt;\n\n\n\nR: Arithmetic Mean\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmean\n\n\nR Documentation\n\n\n\n\n\nArithmetic Mean\n\n\nDescription\n\n\nGeneric function for the (trimmed) arithmetic mean.\n\n\nUsage\n\nmean(x, ...)\n\n## Default S3 method:\nmean(x, trim = 0, na.rm = FALSE, ...)\n\n\nArguments\n\n\n\n\n\nx\n\n\n\nAn R object. Currently there are methods for numeric/logical vectors and date, date-time and time interval objects. Complex vectors are allowed for trim = 0, only.\n\n\n\n\n\ntrim\n\n\n\nthe fraction (0 to 0.5) of observations to be trimmed from each end of x before the mean is computed. Values of trim outside that range are taken as the nearest endpoint.\n\n\n\n\n\nna.rm\n\n\n\na logical evaluating to TRUE or FALSE indicating whether NA values should be stripped before the computation proceeds.\n\n\n\n\n\n…\n\n\n\nfurther arguments passed to or from other methods.\n\n\n\n\n\n\nValue\n\n\nIf trim is zero (the default), the arithmetic mean of the values in x is computed, as a numeric or complex vector of length one. If x is not logical (coerced to numeric), numeric (including integer) or complex, NA_real_ is returned, with a warning.\n\n\nIf trim is non-zero, a symmetrically trimmed mean is computed with a fraction of trim observations deleted from each end before the mean is computed.\n\n\nReferences\n\n\nBecker, R. A., Chambers, J. M. and Wilks, A. R. (1988) The New S Language. Wadsworth & Brooks/Cole.\n\n\nSee Also\n\n\nweighted.mean, mean.POSIXct, colMeans for row and column means.\n\n\nExamples\n\nx &lt;- c(0:10, 50)\nxm &lt;- mean(x)\nc(xm, mean(x, trim = 0.10))\n\n\n\n\n\n\nThe above command displays the help documentation for the mean function, providing information about its usage, arguments, and examples.\n\nThe ?? operator is used for a broader search across help documentation. It performs a search for the specified term or keyword in the documentation.\n\n\n??regression\n\nThis will search for the term “regression” in the help documentation and return relevant results. It’s useful when you want to find functions, packages, or topics related to a specific term.\n\n\n\n\n\n\nTip\n\n\n\nTab completion A very useful feature is Tab completion. You can start typing and use Tab to autocomplete code, for example, a function name."
  },
  {
    "objectID": "vignettes/1_Introduction.html#r-packages",
    "href": "vignettes/1_Introduction.html#r-packages",
    "title": "Basics of R Programming Language",
    "section": "R Packages",
    "text": "R Packages\nMany developers have built 1000s of functions and shared them with the R user community to help make everyone’s work easier and more efficient. These functions (short programs) are generally packaged up together in (wait for it) Packages. For example, the tidyverse package is a compilation of many different functions, all of which help with data transformation and visualization. Packages also contain data, which is often included to assist new users with learning the available functions.\n\nInstalling Packages\nPackages are hosted on repositories, with CRAN (Comprehensive R Archive Network) being the primary repository. To install packages from CRAN, you use the install.packages() function. For example:\n\ninstall.packages(\"tidyverse\")\n\nThis will spit out a lot of text into the console as the package is being installed. Once complete you should have a message:\nThe downloaded binary packages are in... followed by a long directory name.\nTo remove an installed package:\n\nremove.packages(\"tidyverse\")\n\n\n\nLoading Packages\nAfter installation, you need to load a package into your R session using the library() function. For example:\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.0     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nThis makes the functions and datasets from the ‘tidyverse’ package available for use in your current session.\n\n\n\n\n\n\nTip\n\n\n\nYou only need to install a package once. Once installed, you don’t need to reinstall it in subsequent sessions. However, you do need to load the package at the beginning of each R session using the library() function before you can utilize its functions and features. This ensures that the package is actively available for use in your current session.\n\n\nTo view packages currently loaded into memory:\n\n(.packages())\n\n [1] \"lubridate\" \"forcats\"   \"stringr\"   \"dplyr\"     \"purrr\"     \"readr\"    \n [7] \"tidyr\"     \"tibble\"    \"ggplot2\"   \"tidyverse\" \"stats\"     \"graphics\" \n[13] \"grDevices\" \"utils\"     \"datasets\"  \"methods\"   \"base\"     \n\nsearch()\n\n [1] \".GlobalEnv\"        \"package:lubridate\" \"package:forcats\"  \n [4] \"package:stringr\"   \"package:dplyr\"     \"package:purrr\"    \n [7] \"package:readr\"     \"package:tidyr\"     \"package:tibble\"   \n[10] \"package:ggplot2\"   \"package:tidyverse\" \"package:stats\"    \n[13] \"package:graphics\"  \"package:grDevices\" \"package:utils\"    \n[16] \"package:datasets\"  \"package:methods\"   \"Autoloads\"        \n[19] \"package:base\"     \n\n\n\n\nPackage Documentation\nEach package comes with documentation that explains how to use its functions. You can access this information using the help() function or by using ? before the function name:\n\nhelp(tidyverse)\n\n\nView Output\n\n&lt;!DOCTYPE html&gt;\n\n\n\nR: tidyverse: Easily Install and Load the ‘Tidyverse’\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntidyverse-package\n\n\nR Documentation\n\n\n\n\n\ntidyverse: Easily Install and Load the ‘Tidyverse’\n\n\nDescription\n\n\n\n\n\nThe ‘tidyverse’ is a set of packages that work in harmony because they share common data representations and ‘API’ design. This package is designed to make it easy to install and load multiple ‘tidyverse’ packages in a single step. Learn more about the ‘tidyverse’ at https://www.tidyverse.org.\n\n\nAuthor(s)\n\n\nMaintainer: Hadley Wickham hadley@rstudio.com\n\n\nOther contributors:\n\n\n\n\nRStudio [copyright holder, funder]\n\n\n\n\nSee Also\n\n\nUseful links:\n\n\n\n\nhttps://tidyverse.tidyverse.org\n\n\n\n\nhttps://github.com/tidyverse/tidyverse\n\n\n\n\nReport bugs at https://github.com/tidyverse/tidyverse/issues\n\n\n\n\n\n\n\n\nor by using vignette (if the documentation is in the form of vignettes):\n\nvignette(package=\"tidyverse\")"
  },
  {
    "objectID": "vignettes/1_Introduction.html#variables",
    "href": "vignettes/1_Introduction.html#variables",
    "title": "Basics of R Programming Language",
    "section": "Variables",
    "text": "Variables\nA variable is a bit of tricky concept, but very important for understanding R. Essentially, a variable is a symbol that we use in place of another value. Usually the other value is a larger/longer form of data. We can tell R to store a lot of data, for example, in a variable named x. When we execute the command x, R returns all of the data that we stored there.\nFor now however we’ll just use a tiny data set: the number 5. To store some data in a variable, we need to use a special symbol &lt;-, which in our case tells R to assign the value 5 to the variable x. This is called the assignment operator. To insert the assignment operator press Option + - (Mac) or Alt + - (Windows/Linux).\nLet’s see how this works.\nCreate a variable called x, that will contain the number 5.\n\nx &lt;- 5\n\nR won’t return anything in the console, but note that you now have a new entry in the environment pane. The variable name is at the left (x) and the value that is stored in that variable, is displayed on the right (5).\nWe can now use x in place of 5:\n\nx + 10\n\n[1] 15\n\n\n\nx * 3\n\n[1] 15\n\n\nVariables are sometimes referred to as objects. In R there are different conventions about how to name variables, but most importantly they:\n\ncannot begin with a number\nshould begin with an alphabetical letter\nthey are case sensitive\nvariables can take any name, but its best to use something that makes sense to you, and will likely make sense to others who may read your code.\n\nIt is wise to adapt a consistent convention for separating words in variables.\nFor example:\n# i_use_snake_case\n# other.people.use.periods\n# evenOthersUseCamelCase"
  },
  {
    "objectID": "vignettes/1_Introduction.html#the-pipe-operator",
    "href": "vignettes/1_Introduction.html#the-pipe-operator",
    "title": "Basics of R Programming Language",
    "section": "The Pipe Operator (|>)",
    "text": "The Pipe Operator (|&gt;)\nThe pipe operator (|&gt;) is a commonly used feature of the tidyverse. It was originally defined in the (cleverly named) magrittr package, but is also included in the dplyr, tidyverse packages. The |&gt; symbol can seem confusing and intimidating at first. However, once you understand the basic idea, it can become addicting!\nWe suggest you use a shortcut: ⌘ + Shift + M (Mac) or Ctrl + Shift + M (Windows/Linux).\nThe |&gt; symbol is placed between a value on the left and a function on the right. The |&gt; simply takes the value to the left and passes it to the function on the right as the first argument. It acts as a “pipe”. That’s it!\nSuppose we have a variable, x.\n\nx &lt;- 7\n\nThe following are the exact same.\n\nsqrt(x)\n\n[1] 2.645751\n\n\n\nx |&gt; sqrt()\n\n[1] 2.645751\n\n\nWe’ll continue to use |&gt; throughout this tutorial to show how useful it can be for chaining various data manipulation steps during an analysis."
  },
  {
    "objectID": "vignettes/1_Introduction.html#r-data-types",
    "href": "vignettes/1_Introduction.html#r-data-types",
    "title": "Basics of R Programming Language",
    "section": "R Data Types",
    "text": "R Data Types\n\n\n\n\n\n\n\nFigure 1: Image source:https://www.javatpoint.com/r-data-types\n\n\nTo gain a clearer understanding of the remaining content, it is essential to delve into the concept of data types. At this point, we should focus on three fundamental data types:\n\nNumeric data, which involves numbers.\n\n\nvar1 &lt;- 10\nvar2 &lt;- 1L\nvar3 &lt;- 5.5\nvar4 &lt;- 22/7\n\n\nCharacter data, which pertains to words. You can create a string using either single quotes (') or double quotes (\").\n\n\nstr1 &lt;- \"This is a string!!\"\nstr2 &lt;- 'A'\n\n\nLogical data, encapsulating TRUE/FALSE values.\n\n\nbool1 &lt;- T\nbool2 &lt;- FALSE\n\nYou can check the data type of a variable by using the class() function. For example:\n\nclass(var3) \nclass(bool1)\n\nApply the class() function to the remaining variables defined earlier."
  },
  {
    "objectID": "vignettes/1_Introduction.html#sec-comparison",
    "href": "vignettes/1_Introduction.html#sec-comparison",
    "title": "Basics of R Programming Language",
    "section": "Comparison Operators and Expressions",
    "text": "Comparison Operators and Expressions\nLet’s take a moment to discuss logical operators and expressions for questioning the attributes of our objects.\n\n== – ‘equal to’\n!= – ‘not equal to’\n&lt; – ‘less than’\n&gt; – ‘greater than’\n&lt;= – ‘less than or equal to’\n&gt;= – ‘greater than or equal to’\n\n\nx &lt;- 20\nx == 2\n\n[1] FALSE\n\nx &lt;= 50\n\n[1] TRUE\n\nx != 20\n\n[1] FALSE"
  },
  {
    "objectID": "vignettes/1_Introduction.html#sec-logical",
    "href": "vignettes/1_Introduction.html#sec-logical",
    "title": "Basics of R Programming Language",
    "section": "Logical Operators and Expressions",
    "text": "Logical Operators and Expressions\nLogical operators are used to combine or compare logical statements. They allow us to create complex conditions by combining simpler conditions.\n\n& (AND): Returns TRUE only if both the conditions on the left and right are TRUE.\n| (OR): Returns TRUE if at least one of the conditions on the left or right is TRUE.\n! (NOT): Negates the logical value of the condition; if the condition is TRUE, ! makes it FALSE, and vice versa.\n\n\na &lt;- TRUE\na & a\n\n[1] TRUE\n\na & !a\n\n[1] FALSE\n\n!a | a\n\n[1] TRUE"
  },
  {
    "objectID": "vignettes/1_Introduction.html#r-data-structures",
    "href": "vignettes/1_Introduction.html#r-data-structures",
    "title": "Basics of R Programming Language",
    "section": "R Data Structures",
    "text": "R Data Structures\nR use several data structures to organize and manipulate data.\n\n\n\n\n\n\nVectors\nVectors are one-dimensional arrays that can hold elements of the same data type. Ordinarily, we need to enclose values in brackets, separated by commas. The values also need to be ‘concatenated’ using a function called c().\n\nnumeric_vector &lt;- c(3, 6, 9, 12)\ncharacter_vector &lt;- c('R', 'Python', 'Java', 'C')\nlogical_vector &lt;- c(TRUE, TRUE, FALSE, FALSE)\n\n\n\nLists\nLists are one-dimensional or nested structures that can contain elements of different data types.\n\nmixed_list &lt;- list(1, \"apple\", TRUE, 3.14)\nnested_list &lt;- list(c(1, 2, 3), \"hello\", list(4, 5, 6))\nnested_list\n\n\nOutput\n\n\n[[1]]\n[1] 1 2 3\n\n[[2]]\n[1] \"hello\"\n\n[[3]]\n[[3]][[1]]\n[1] 4\n\n[[3]][[2]]\n[1] 5\n\n[[3]][[3]]\n[1] 6\n\n\n\n\n\nMatrices\nMatrices are two-dimensional arrays with rows and columns containing elements of the same data type.\n\nnumeric_matrix &lt;- matrix(1:6, nrow = 2, ncol = 3)\nnumeric_matrix\n\n\nOutput\n\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n\n\n\n\nArrays\nArrays are multi-dimensional structures that can hold elements of the same data type.\n\nnumeric_array &lt;- array(1:12, dim = c(2, 3, 2))\nnumeric_array\n\n\nOutput\n\n\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    7    9   11\n[2,]    8   10   12\n\n\n\n\n\nData Frames\nData frames are two-dimensional structures similar to matrices, but they can store different data types in each column. Data frames generally have column names, which we can treat in the same way as a variable.\nFor example, let’s combine our three vectors into a data frame, using the data.frame() function:\n\n#combine vectors of the same length into a data frame\nnew_df &lt;- data.frame(numeric_vector, character_vector, logical_vector)\nnew_df\n\n\nOutput\n\n\n  numeric_vector character_vector logical_vector\n1              3                R           TRUE\n2              6           Python           TRUE\n3              9             Java          FALSE\n4             12                C          FALSE\n\n\n\nImportantly, each column in a data frame must have the same number of values (i.e., the same number of rows). This will be a familiar data structure for those who use Microsoft Excel, and is very popular in data science.\n\nTibbles\nA tibble is a modern and enhanced version of a data frame, introduced by the tidyverse collection of packages. They are data frames but they tweak some behaviors to make coding a little bit easier.\n\nnew_tbl = tibble(\nx = c(0,2,4,6),   \ny = c('great','fabulous','yeay', 'amazing'), \nz = x^2 + 3) \nnew_tbl\n\n\nOutput\n\n\n# A tibble: 4 × 3\n      x y            z\n  &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt;\n1     0 great        3\n2     2 fabulous     7\n3     4 yeay        19\n4     6 amazing     39\n\n\n\nIn this workshop, we will use the terms tibble and data frame interchangeably. We will extensively use data frames (or tibbles) in the remainder of this workshop.\n\n\n\nFactors\nFactors are used to represent categorical data with distinct levels or categories.\nImagine that you have a variable that records months:\n\nx1 &lt;- c(\"Dec\", \"Apr\", \"Jan\", \"Mar\")\n\nUsing a list of strings to record this variable has two problems:\n\nThere are only twelve possible months, and there’s nothing saving you from typos:\n\n\nx2 &lt;- c(\"Dec\", \"Apr\", \"Jam\", \"Mar\")\n\n\nIt doesn’t sort in a useful way:\n\n\nsort(x1)\n\n[1] \"Apr\" \"Dec\" \"Jan\" \"Mar\"\n\n\nYou can fix both of these problems with a factor. To create a factor you must start by creating a list of the valid levels:\n\nmonth_levels &lt;- c(\n  \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \n  \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n)\n\nNow you can create a factor:\n\ny1 &lt;- factor(x1, levels = month_levels)\ny1\n\n[1] Dec Apr Jan Mar\nLevels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n\n\nSort it using the sort() function:\n\nsort(y1)\n\n[1] Jan Mar Apr Dec\nLevels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n\n\nAnd any values not in the level will be silently converted to NA (Not Available):\n\ny2 &lt;- factor(x2, levels = month_levels)\ny2\n\n[1] Dec  Apr  &lt;NA&gt; Mar \nLevels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n\n\nFactors have predefined levels, which are the distinct categories that the data can belong to. They can be ordered or unordered. Internally, factors are represented as integers, with each level mapped to a specific integer value. This integer representation is useful for efficient storage and certain statistical analyses (including sorting)."
  },
  {
    "objectID": "vignettes/1_Introduction.html#clearing-the-environment",
    "href": "vignettes/1_Introduction.html#clearing-the-environment",
    "title": "Basics of R Programming Language",
    "section": "Clearing the Environment",
    "text": "Clearing the Environment\nTake a look at the objects you have created in your workspace that is accumulated in the environment pane in the upper right corner of RStudio.\n\n\n\n\n\nYou can obtain a list of objects in your workspace using a couple of different R commands:\n\nobjects()\n\n\nOutput\n\n\n [1] \"a\"                \"bool1\"            \"bool2\"            \"character_vector\"\n [5] \"has_annotations\"  \"logical_vector\"   \"mixed_list\"       \"month_levels\"    \n [9] \"nested_list\"      \"new_df\"           \"new_tbl\"          \"numeric_array\"   \n[13] \"numeric_matrix\"   \"numeric_vector\"   \"str1\"             \"str2\"            \n[17] \"var1\"             \"var2\"             \"var3\"             \"var4\"            \n[21] \"x\"                \"x1\"               \"x2\"               \"y1\"              \n[25] \"y2\"              \n\n\n\n\nls()\n\n\nOutput\n\n\n [1] \"a\"                \"bool1\"            \"bool2\"            \"character_vector\"\n [5] \"has_annotations\"  \"logical_vector\"   \"mixed_list\"       \"month_levels\"    \n [9] \"nested_list\"      \"new_df\"           \"new_tbl\"          \"numeric_array\"   \n[13] \"numeric_matrix\"   \"numeric_vector\"   \"str1\"             \"str2\"            \n[17] \"var1\"             \"var2\"             \"var3\"             \"var4\"            \n[21] \"x\"                \"x1\"               \"x2\"               \"y1\"              \n[25] \"y2\"              \n\n\n\nIf you wish to remove a specific object, let’s say x1, you can use the following command:\nrm(x1)\nTo remove all objects:\nrm(list = ls())\nAlternatively, you can click the broom icon in RStudio’s Environment pane to clear everything.\nFor the sake of reproducibility, it’s crucial to regularly delete your objects and restart your R session. This ensures that your analysis can be replicated next week or even after upgrading your operating system. Restarting your R session helps identify and address any dependencies or configurations needed for your analysis to run successfully."
  },
  {
    "objectID": "vignettes/3_Data_Manipulation.html",
    "href": "vignettes/3_Data_Manipulation.html",
    "title": "Step 3: Transforming Data",
    "section": "",
    "text": "The dplyr package (part of the tidyverse), aims to simplify the process of manipulating and transforming data in a straightforward and user-friendly manner. This is the second step in the tidyverse workflow.\nA central principle of tidyverse packages, is the emphasis on minimizing the number of keystrokes and characters needed to attain desired results. In dplyr, the use of quotation marks for column names in data frames is often unnecessary. Another noteworthy aspect is that both the input to and output from all functions are in the form of data frames.\ndplyr package offers a set of key functions, referred to as ‘verbs’, which can be combined to achieve specific and targeted outcomes. Users familiar with functions in Microsoft Excel may recognize similarities in the functionality provided by dplyr.\nBefore we delve into these functions in detail, let’s first explore filtering or subsetting data frames using base R functions."
  },
  {
    "objectID": "vignettes/3_Data_Manipulation.html#subsetting-data-frames",
    "href": "vignettes/3_Data_Manipulation.html#subsetting-data-frames",
    "title": "Step 3: Transforming Data",
    "section": "Subsetting Data Frames",
    "text": "Subsetting Data Frames\nA frequently encountered task in data manipulation is filtering or subsetting data to a more focused and potentially relevant subset of values. Data frames (or tibbles) can be subset using base R functions.\nLet’s start by reading the cms_hospital_patient_satisfaction_2016_sampled.csv into a data frame using the read_csv() function in readr packgae:\n\nlibrary(readr)\n# here the first argument is a path\ncms_data &lt;- read_csv(\"data/patient_satisfaction/cms_hospital_patient_satisfaction_2016_sampled.csv\")\n# convert column names to R standard\nlibrary(janitor) # remember to install janitor: install.packages(\"janitor\")\ncms_data &lt;- cms_data |&gt; clean_names()\n\n\nSubset by position\nHere we use the [row, col] syntax to subset data frames.\n\nTo display a single value:\n\n\n# display the value in 4th row and 2nd column\ncms_data[4, 2]\n\n\nOutput\n\n\n# A tibble: 1 × 1\n  facility_name            \n  &lt;chr&gt;                    \n1 MERCY HOSPITAL FORT SMITH\n\n\n\n\nTo display a single row: Here, the column value is omitted, thereby retrieving the entire column.\n\n\n# display the 4th row\ncms_data[4,]\n\n\nOutput\n\n\n# A tibble: 1 × 8\n  id     facility_name            county hospital_type star_rating no_of_surveys\n  &lt;chr&gt;  &lt;chr&gt;                    &lt;chr&gt;  &lt;chr&gt;               &lt;dbl&gt;         &lt;dbl&gt;\n1 040062 MERCY HOSPITAL FORT SMI… SEBAS… Acute Care H…           3          2506\n# ℹ 2 more variables: response_rate &lt;dbl&gt;, overall_rating &lt;dbl&gt;\n\n\n\n\nTo display a single column: (Note: columns can be given by name as well) Here, the row value is omitted, thereby retrieving the entire column.\n\n\n# display the 3rd column\ncms_data[, 3] # is same as cms_data[3]\n# display the 3rd column (or County column)\ncms_data[, \"county\"] # is same as cms_data[\"County\"]\n\n\nOutput\n\n\n# A tibble: 15 × 1\n   county        \n   &lt;chr&gt;         \n 1 SAN DIEGO     \n 2 COOK          \n 3 LAKE          \n 4 SEBASTIAN     \n 5 SHELBY        \n 6 BRAZOS        \n 7 GREENE        \n 8 MONTEZUMA     \n 9 VIRGINIA BEACH\n10 FAYETTE       \n11 LOS ANGELES   \n12 MIAMI-DADE    \n13 SUMNER        \n14 ISLAND        \n15 LOS ANGELES   \n\n\n# A tibble: 15 × 1\n   county        \n   &lt;chr&gt;         \n 1 SAN DIEGO     \n 2 COOK          \n 3 LAKE          \n 4 SEBASTIAN     \n 5 SHELBY        \n 6 BRAZOS        \n 7 GREENE        \n 8 MONTEZUMA     \n 9 VIRGINIA BEACH\n10 FAYETTE       \n11 LOS ANGELES   \n12 MIAMI-DADE    \n13 SUMNER        \n14 ISLAND        \n15 LOS ANGELES   \n\n\n\n\nTo display a range of rows:\n\n\n# using a vector of indexes\ncms_data[c(3, 5, 1), ]\n# subsetting\ncms_data[2:4,]\n\n\nOutput\n\n\n# A tibble: 3 × 8\n  id     facility_name            county hospital_type star_rating no_of_surveys\n  &lt;chr&gt;  &lt;chr&gt;                    &lt;chr&gt;  &lt;chr&gt;               &lt;dbl&gt;         &lt;dbl&gt;\n1 100051 SOUTH LAKE HOSPITAL      LAKE   Acute Care H…           2          1382\n2 440048 BAPTIST MEMORIAL HOSPIT… SHELBY Acute Care H…           2          1799\n3 050424 SCRIPPS GREEN HOSPITAL   SAN D… Acute Care H…           4          3110\n# ℹ 2 more variables: response_rate &lt;dbl&gt;, overall_rating &lt;dbl&gt;\n\n\n# A tibble: 3 × 8\n  id     facility_name            county hospital_type star_rating no_of_surveys\n  &lt;chr&gt;  &lt;chr&gt;                    &lt;chr&gt;  &lt;chr&gt;               &lt;dbl&gt;         &lt;dbl&gt;\n1 140103 ST BERNARD HOSPITAL      COOK   Acute Care H…           1           264\n2 100051 SOUTH LAKE HOSPITAL      LAKE   Acute Care H…           2          1382\n3 040062 MERCY HOSPITAL FORT SMI… SEBAS… Acute Care H…           3          2506\n# ℹ 2 more variables: response_rate &lt;dbl&gt;, overall_rating &lt;dbl&gt;\n\n\n\n\nTo display a range of columns:\n\n\n# using a vector of indexes\ncms_data[, c(1, 3, 6), ]\n# subsetting\ncms_data[, 4:6]\n# using a vector of column names\ncms_data[, c(\"hospital_type\", \"overall_rating\")]\n\n\nOutput\n\n\n# A tibble: 15 × 3\n   id     county         no_of_surveys\n   &lt;chr&gt;  &lt;chr&gt;                  &lt;dbl&gt;\n 1 050424 SAN DIEGO               3110\n 2 140103 COOK                     264\n 3 100051 LAKE                    1382\n 4 040062 SEBASTIAN               2506\n 5 440048 SHELBY                  1799\n 6 450011 BRAZOS                  1379\n 7 151317 GREENE                   114\n 8 061327 MONTEZUMA                247\n 9 490057 VIRGINIA BEACH           619\n10 110215 FAYETTE                 1714\n11 050704 LOS ANGELES              241\n12 100296 MIAMI-DADE               393\n13 440003 SUMNER                   680\n14 501339 ISLAND                   389\n15 050116 LOS ANGELES             1110\n\n\n# A tibble: 15 × 3\n   hospital_type            star_rating no_of_surveys\n   &lt;chr&gt;                          &lt;dbl&gt;         &lt;dbl&gt;\n 1 Acute Care Hospital                4          3110\n 2 Acute Care Hospital                1           264\n 3 Acute Care Hospital                2          1382\n 4 Acute Care Hospital                3          2506\n 5 Acute Care Hospital                2          1799\n 6 Acute Care Hospital                3          1379\n 7 Critical Access Hospital           3           114\n 8 Critical Access Hospital           4           247\n 9 Acute Care Hospital                4           619\n10 Acute Care Hospital                2          1714\n11 Acute Care Hospital                3           241\n12 Acute Care Hospital                4           393\n13 Acute Care Hospital                4           680\n14 Critical Access Hospital           3           389\n15 Acute Care Hospital                3          1110\n\n\n# A tibble: 15 × 2\n   hospital_type            overall_rating\n   &lt;chr&gt;                             &lt;dbl&gt;\n 1 Acute Care Hospital                   5\n 2 Acute Care Hospital                   2\n 3 Acute Care Hospital                   2\n 4 Acute Care Hospital                   3\n 5 Acute Care Hospital                   2\n 6 Acute Care Hospital                   3\n 7 Critical Access Hospital              3\n 8 Critical Access Hospital              3\n 9 Acute Care Hospital                   3\n10 Acute Care Hospital                   2\n11 Acute Care Hospital                   3\n12 Acute Care Hospital                   3\n13 Acute Care Hospital                   2\n14 Critical Access Hospital              3\n15 Acute Care Hospital                   2\n\n\n\n\nTo display multiple rows and columns:\n\n\ncms_data[2:6, c(\"hospital_type\", \"no_of_surveys\", \"response_rate\")]\n\n\nOutput\n\n\n# A tibble: 5 × 3\n  hospital_type       no_of_surveys response_rate\n  &lt;chr&gt;                       &lt;dbl&gt;         &lt;dbl&gt;\n1 Acute Care Hospital           264             6\n2 Acute Care Hospital          1382            20\n3 Acute Care Hospital          2506            35\n4 Acute Care Hospital          1799            18\n5 Acute Care Hospital          1379            24\n\n\n\n\nTo exclude a column (use - size):\n\n\n# display the data frame without Star_rating column\ncms_data[-5]\n# display the data frame, include only the hospital information and location\ncms_data[c(-5, -6, -7, -8)] # or cms_data[c(1, 2, 3, 4)]\n\n\nOutput\n\n\n# A tibble: 15 × 7\n   id     facility_name         county hospital_type no_of_surveys response_rate\n   &lt;chr&gt;  &lt;chr&gt;                 &lt;chr&gt;  &lt;chr&gt;                 &lt;dbl&gt;         &lt;dbl&gt;\n 1 050424 SCRIPPS GREEN HOSPIT… SAN D… Acute Care H…          3110            41\n 2 140103 ST BERNARD HOSPITAL   COOK   Acute Care H…           264             6\n 3 100051 SOUTH LAKE HOSPITAL   LAKE   Acute Care H…          1382            20\n 4 040062 MERCY HOSPITAL FORT … SEBAS… Acute Care H…          2506            35\n 5 440048 BAPTIST MEMORIAL HOS… SHELBY Acute Care H…          1799            18\n 6 450011 ST JOSEPH REGIONAL H… BRAZOS Acute Care H…          1379            24\n 7 151317 GREENE COUNTY GENERA… GREENE Critical Acc…           114            22\n 8 061327 SOUTHWEST MEMORIAL H… MONTE… Critical Acc…           247            34\n 9 490057 SENTARA GENERAL HOSP… VIRGI… Acute Care H…           619            32\n10 110215 PIEDMONT FAYETTE HOS… FAYET… Acute Care H…          1714            21\n11 050704 MISSION COMMUNITY HO… LOS A… Acute Care H…           241            14\n12 100296 DOCTORS HOSPITAL      MIAMI… Acute Care H…           393            24\n13 440003 SUMNER REGIONAL MEDI… SUMNER Acute Care H…           680            35\n14 501339 WHIDBEY GENERAL HOSP… ISLAND Critical Acc…           389            29\n15 050116 NORTHRIDGE MEDICAL C… LOS A… Acute Care H…          1110            20\n# ℹ 1 more variable: overall_rating &lt;dbl&gt;\n\n\n# A tibble: 15 × 4\n   id     facility_name                    county         hospital_type         \n   &lt;chr&gt;  &lt;chr&gt;                            &lt;chr&gt;          &lt;chr&gt;                 \n 1 050424 SCRIPPS GREEN HOSPITAL           SAN DIEGO      Acute Care Hospital   \n 2 140103 ST BERNARD HOSPITAL              COOK           Acute Care Hospital   \n 3 100051 SOUTH LAKE HOSPITAL              LAKE           Acute Care Hospital   \n 4 040062 MERCY HOSPITAL FORT SMITH        SEBASTIAN      Acute Care Hospital   \n 5 440048 BAPTIST MEMORIAL HOSPITAL        SHELBY         Acute Care Hospital   \n 6 450011 ST JOSEPH REGIONAL HEALTH CENTER BRAZOS         Acute Care Hospital   \n 7 151317 GREENE COUNTY GENERAL HOSPITAL   GREENE         Critical Access Hospi…\n 8 061327 SOUTHWEST MEMORIAL HOSPITAL      MONTEZUMA      Critical Access Hospi…\n 9 490057 SENTARA GENERAL HOSPITAL         VIRGINIA BEACH Acute Care Hospital   \n10 110215 PIEDMONT FAYETTE HOSPITAL        FAYETTE        Acute Care Hospital   \n11 050704 MISSION COMMUNITY HOSPITAL       LOS ANGELES    Acute Care Hospital   \n12 100296 DOCTORS HOSPITAL                 MIAMI-DADE     Acute Care Hospital   \n13 440003 SUMNER REGIONAL MEDICAL CENTER   SUMNER         Acute Care Hospital   \n14 501339 WHIDBEY GENERAL HOSPITAL         ISLAND         Critical Access Hospi…\n15 050116 NORTHRIDGE MEDICAL CENTER        LOS ANGELES    Acute Care Hospital   \n\n\n\n\n\nSubset by condition\nApart from subsetting a vector based on the position of values, we can also ask questions about the set of values to R, and it will respond with TRUE or FALSE answers. This is often done using logical expressions to filter the data.\n\nWhich cells contain the value “LOS ANGELES”?\n\n\ncms_data == \"LOS ANGELES\"\n\n\nOutput\n\n\n         id facility_name county hospital_type star_rating no_of_surveys\n [1,] FALSE         FALSE  FALSE         FALSE       FALSE         FALSE\n [2,] FALSE         FALSE  FALSE         FALSE       FALSE         FALSE\n [3,] FALSE         FALSE  FALSE         FALSE       FALSE         FALSE\n [4,] FALSE         FALSE  FALSE         FALSE       FALSE         FALSE\n [5,] FALSE         FALSE  FALSE         FALSE       FALSE         FALSE\n [6,] FALSE         FALSE  FALSE         FALSE       FALSE         FALSE\n [7,] FALSE         FALSE  FALSE         FALSE       FALSE         FALSE\n [8,] FALSE         FALSE  FALSE         FALSE       FALSE         FALSE\n [9,] FALSE         FALSE  FALSE         FALSE       FALSE         FALSE\n[10,] FALSE         FALSE  FALSE         FALSE       FALSE         FALSE\n[11,] FALSE         FALSE   TRUE         FALSE       FALSE         FALSE\n[12,] FALSE         FALSE  FALSE         FALSE       FALSE         FALSE\n[13,] FALSE         FALSE  FALSE         FALSE       FALSE         FALSE\n[14,] FALSE         FALSE  FALSE         FALSE       FALSE         FALSE\n[15,] FALSE         FALSE   TRUE         FALSE       FALSE         FALSE\n      response_rate overall_rating\n [1,]         FALSE          FALSE\n [2,]         FALSE          FALSE\n [3,]         FALSE          FALSE\n [4,]         FALSE          FALSE\n [5,]         FALSE          FALSE\n [6,]         FALSE          FALSE\n [7,]         FALSE          FALSE\n [8,]         FALSE          FALSE\n [9,]         FALSE          FALSE\n[10,]         FALSE          FALSE\n[11,]         FALSE          FALSE\n[12,]         FALSE          FALSE\n[13,]         FALSE          FALSE\n[14,]         FALSE          FALSE\n[15,]         FALSE          FALSE\n\n\n\nR returns TRUE for values that satisfy the condition, and FALSE for those that don’t.\nHow many cells contain the word “LOS ANGELES”?\nWe can use the sum() function to compute the number of occurrences of “LOS ANGELES” in the data frame as it treats TRUE as 1 and FALSE as 0.\n\nsum(cms_data == \"LOS ANGELES\")\n\n\nOutput\n\n\n[1] 2\n\n\n\n\nWhich cells contain the value 3?\n\n\ncms_data == 3\n\n\nOutput\n\n\n         id facility_name county hospital_type star_rating no_of_surveys\n [1,] FALSE         FALSE  FALSE         FALSE       FALSE         FALSE\n [2,] FALSE         FALSE  FALSE         FALSE       FALSE         FALSE\n [3,] FALSE         FALSE  FALSE         FALSE       FALSE         FALSE\n [4,] FALSE         FALSE  FALSE         FALSE        TRUE         FALSE\n [5,] FALSE         FALSE  FALSE         FALSE       FALSE         FALSE\n [6,] FALSE         FALSE  FALSE         FALSE        TRUE         FALSE\n [7,] FALSE         FALSE  FALSE         FALSE        TRUE         FALSE\n [8,] FALSE         FALSE  FALSE         FALSE       FALSE         FALSE\n [9,] FALSE         FALSE  FALSE         FALSE       FALSE         FALSE\n[10,] FALSE         FALSE  FALSE         FALSE       FALSE         FALSE\n[11,] FALSE         FALSE  FALSE         FALSE        TRUE         FALSE\n[12,] FALSE         FALSE  FALSE         FALSE       FALSE         FALSE\n[13,] FALSE         FALSE  FALSE         FALSE       FALSE         FALSE\n[14,] FALSE         FALSE  FALSE         FALSE        TRUE         FALSE\n[15,] FALSE         FALSE  FALSE         FALSE        TRUE         FALSE\n      response_rate overall_rating\n [1,]         FALSE          FALSE\n [2,]         FALSE          FALSE\n [3,]         FALSE          FALSE\n [4,]         FALSE           TRUE\n [5,]         FALSE          FALSE\n [6,]         FALSE           TRUE\n [7,]         FALSE           TRUE\n [8,]         FALSE           TRUE\n [9,]         FALSE           TRUE\n[10,]         FALSE          FALSE\n[11,]         FALSE           TRUE\n[12,]         FALSE           TRUE\n[13,]         FALSE          FALSE\n[14,]         FALSE           TRUE\n[15,]         FALSE          FALSE\n\n\n\nWe will use the comparison operators (see Section: Comparison Operators and Expressions) and logical operators (see Section: Logical Operators and Expressions) we explored in the subsequent sections.\n\nFind all the facilities with a star rating above 3.\n\n\nsr_above_3 &lt;- cms_data$star_rating &gt; 3\ncms_data[sr_above_3, ]\n\n\nOutput\n\n\n# A tibble: 5 × 8\n  id     facility_name            county hospital_type star_rating no_of_surveys\n  &lt;chr&gt;  &lt;chr&gt;                    &lt;chr&gt;  &lt;chr&gt;               &lt;dbl&gt;         &lt;dbl&gt;\n1 050424 SCRIPPS GREEN HOSPITAL   SAN D… Acute Care H…           4          3110\n2 061327 SOUTHWEST MEMORIAL HOSP… MONTE… Critical Acc…           4           247\n3 490057 SENTARA GENERAL HOSPITAL VIRGI… Acute Care H…           4           619\n4 100296 DOCTORS HOSPITAL         MIAMI… Acute Care H…           4           393\n5 440003 SUMNER REGIONAL MEDICAL… SUMNER Acute Care H…           4           680\n# ℹ 2 more variables: response_rate &lt;dbl&gt;, overall_rating &lt;dbl&gt;\n\n\n\n\nFind all the facility names with a star rating above 2.\n\n\ncms_data[sr_above_3, 2]\n\n\nOutput\n\n\n# A tibble: 5 × 1\n  facility_name                 \n  &lt;chr&gt;                         \n1 SCRIPPS GREEN HOSPITAL        \n2 SOUTHWEST MEMORIAL HOSPITAL   \n3 SENTARA GENERAL HOSPITAL      \n4 DOCTORS HOSPITAL              \n5 SUMNER REGIONAL MEDICAL CENTER\n\n\n\n\nFind all the facilities with an overall rating of at least 3 and the response rate is above 30%.\n\n\n# overall rating of at least 3\norate_aleast_3 &lt;- cms_data[\"overall_rating\"] &gt;= 3\n# response rate above 30\\%\nrrate_above_30 &lt;- cms_data[7] &gt; 30\n# both conditions has to satisfy. hence and (&) operator\ncms_data[(orate_aleast_3 & rrate_above_30), ]\n\n\nOutput\n\n\n# A tibble: 4 × 8\n  id     facility_name            county hospital_type star_rating no_of_surveys\n  &lt;chr&gt;  &lt;chr&gt;                    &lt;chr&gt;  &lt;chr&gt;               &lt;dbl&gt;         &lt;dbl&gt;\n1 050424 SCRIPPS GREEN HOSPITAL   SAN D… Acute Care H…           4          3110\n2 040062 MERCY HOSPITAL FORT SMI… SEBAS… Acute Care H…           3          2506\n3 061327 SOUTHWEST MEMORIAL HOSP… MONTE… Critical Acc…           4           247\n4 490057 SENTARA GENERAL HOSPITAL VIRGI… Acute Care H…           4           619\n# ℹ 2 more variables: response_rate &lt;dbl&gt;, overall_rating &lt;dbl&gt;\n\n\n\n\n# the above 3 commands can be combined into a single-line command\ncms_data[(cms_data[\"overall_rating\"] &gt;= 3) & (cms_data[7] &gt; 30), ]\n\n\nOutput\n\n\n# A tibble: 4 × 8\n  id     facility_name            county hospital_type star_rating no_of_surveys\n  &lt;chr&gt;  &lt;chr&gt;                    &lt;chr&gt;  &lt;chr&gt;               &lt;dbl&gt;         &lt;dbl&gt;\n1 050424 SCRIPPS GREEN HOSPITAL   SAN D… Acute Care H…           4          3110\n2 040062 MERCY HOSPITAL FORT SMI… SEBAS… Acute Care H…           3          2506\n3 061327 SOUTHWEST MEMORIAL HOSP… MONTE… Critical Acc…           4           247\n4 490057 SENTARA GENERAL HOSPITAL VIRGI… Acute Care H…           4           619\n# ℹ 2 more variables: response_rate &lt;dbl&gt;, overall_rating &lt;dbl&gt;\n\n\n\nOperators in R have a specific precedence, and they are executed either from left \\(\\rightarrow\\) right or right \\(\\rightarrow\\) left. This can impact the expected result if you are not mindful of operator precedence. It is advisable to use parentheses to explicitly define the order of operations since parentheses have the highest precedence. Refer to this image for a operator precedence table.\nFor example: 5 + 3 * 2 is not the same as (5 + 3) * 2. The multiplication operation takes precedence over addition, potentially leading to unexpected results. Using parentheses ensures that the addition operation is performed first, providing the desired outcome.\n\nFind the county of hospitals with any rating greater than or equal to 3.\n\n\n# there are two ratings:\n# 1. star_rating &gt;= 3\nsrate_3 &lt;- cms_data$star_rating &gt;= 3\n# 2. overall_rating &gt;= 3\norate_3 &lt;- cms_data[\"overall_rating\"] &gt;= 3\n# any means at least one has to be &gt;= 3 -&gt; or operator\ncms_data[srate_3 | orate_3, ]\n# we only needs the county names\ncms_data[srate_3 | orate_3, \"county\"]\n\n\nOutput\n\n\n# A tibble: 11 × 8\n   id     facility_name           county hospital_type star_rating no_of_surveys\n   &lt;chr&gt;  &lt;chr&gt;                   &lt;chr&gt;  &lt;chr&gt;               &lt;dbl&gt;         &lt;dbl&gt;\n 1 050424 SCRIPPS GREEN HOSPITAL  SAN D… Acute Care H…           4          3110\n 2 040062 MERCY HOSPITAL FORT SM… SEBAS… Acute Care H…           3          2506\n 3 450011 ST JOSEPH REGIONAL HEA… BRAZOS Acute Care H…           3          1379\n 4 151317 GREENE COUNTY GENERAL … GREENE Critical Acc…           3           114\n 5 061327 SOUTHWEST MEMORIAL HOS… MONTE… Critical Acc…           4           247\n 6 490057 SENTARA GENERAL HOSPIT… VIRGI… Acute Care H…           4           619\n 7 050704 MISSION COMMUNITY HOSP… LOS A… Acute Care H…           3           241\n 8 100296 DOCTORS HOSPITAL        MIAMI… Acute Care H…           4           393\n 9 440003 SUMNER REGIONAL MEDICA… SUMNER Acute Care H…           4           680\n10 501339 WHIDBEY GENERAL HOSPIT… ISLAND Critical Acc…           3           389\n11 050116 NORTHRIDGE MEDICAL CEN… LOS A… Acute Care H…           3          1110\n# ℹ 2 more variables: response_rate &lt;dbl&gt;, overall_rating &lt;dbl&gt;\n\n\n# A tibble: 11 × 1\n   county        \n   &lt;chr&gt;         \n 1 SAN DIEGO     \n 2 SEBASTIAN     \n 3 BRAZOS        \n 4 GREENE        \n 5 MONTEZUMA     \n 6 VIRGINIA BEACH\n 7 LOS ANGELES   \n 8 MIAMI-DADE    \n 9 SUMNER        \n10 ISLAND        \n11 LOS ANGELES   \n\n\n\n\nHow many hospitals are categorized as Acute Care Hospital?\n\n\n# all the hospitals categorized as Acute Care Hospitals \nhosp_acute &lt;- cms_data$hospital_type == \"Acute Care Hospital\"\n# summing the vector of TRUE (1) and FALSE (0) values \nsum(hosp_acute)\n\n\nOutput\n\n\n[1] 12\n\n\n\n\nFind the summary statistics number of surveys conducted at Critical Access Hospital.\n\n\n# all the hospitals categorized as Critical Access Hospitals\nhosp_crit &lt;- cms_data$hospital_type == \"Critical Access Hospital\"\n# number of surveys conducted in Critical Access Hospitals\nnsurv_crit &lt;- cms_data[hosp_crit, \"no_of_surveys\"]\n# summary statistics of the number of surveys\nsummary(nsurv_crit)\n\n\nOutput\n\n\n no_of_surveys  \n Min.   :114.0  \n 1st Qu.:180.5  \n Median :247.0  \n Mean   :250.0  \n 3rd Qu.:318.0  \n Max.   :389.0  \n\n\n\nThis approach can be somewhat cumbersome. It requires repeated referencing of the data frame name, leading to a multiple use of punctuation that needs careful management. In the following section, we will leverage the dplyrpackage and its functions to craft more concise code, and efficient data manipulations."
  },
  {
    "objectID": "vignettes/3_Data_Manipulation.html#data-manipulation-with-dplyr-functions",
    "href": "vignettes/3_Data_Manipulation.html#data-manipulation-with-dplyr-functions",
    "title": "Step 3: Transforming Data",
    "section": "Data manipulation with `dplyr’ functions",
    "text": "Data manipulation with `dplyr’ functions\nYou’ll primarily use five key dplyr functions for data manipulations:\n\nfilter(): pick observations based on their values.\nselect(): pick variables by their names.\nmutate(): create new variables using functions applied to existing variables.\nsummarise(): collapse multiple values into a single summary.\ngroup_by(): group the rows based on specified criteria.\narrange(): reorder the rows based on specified criteria.\n\nIf you’ve already installed the tidyverse package (if not, you can do so by running the command: install.packages(\"tidyverse\")), let’s proceed to load it into our R session first:\n\nlibrary(tidyverse)\n\n\nfilter()\nThe filter() function takes logical expressions and returns the rows for which all are TRUE.\n\nExample 1: Filter the cms_data data frame to find all the facilities with an overall_rating of 3.\n\ncms_data |&gt; filter(overall_rating == 3)\n\n\nOutput\n\n\n# A tibble: 8 × 8\n  id     facility_name            county hospital_type star_rating no_of_surveys\n  &lt;chr&gt;  &lt;chr&gt;                    &lt;chr&gt;  &lt;chr&gt;               &lt;dbl&gt;         &lt;dbl&gt;\n1 040062 MERCY HOSPITAL FORT SMI… SEBAS… Acute Care H…           3          2506\n2 450011 ST JOSEPH REGIONAL HEAL… BRAZOS Acute Care H…           3          1379\n3 151317 GREENE COUNTY GENERAL H… GREENE Critical Acc…           3           114\n4 061327 SOUTHWEST MEMORIAL HOSP… MONTE… Critical Acc…           4           247\n5 490057 SENTARA GENERAL HOSPITAL VIRGI… Acute Care H…           4           619\n6 050704 MISSION COMMUNITY HOSPI… LOS A… Acute Care H…           3           241\n7 100296 DOCTORS HOSPITAL         MIAMI… Acute Care H…           4           393\n8 501339 WHIDBEY GENERAL HOSPITAL ISLAND Critical Acc…           3           389\n# ℹ 2 more variables: response_rate &lt;dbl&gt;, overall_rating &lt;dbl&gt;\n\n\n\nHere we are sending the cms_data data frame into the function filter() which tests each value in overall_rating column for the value 3 and returns the rows where this condition is TRUE.\nYou can check the dimension (number of rows and number of columns) of the resulting data frame by sending into the dim() function as follows:\n\ncms_data |&gt; filter(overall_rating == 3) |&gt; dim()\n\n\nOutput\n\n\n[1] 8 8\n\n\n\nExample 2: Find all the facilities categorized as “Acute Care Hospital”. Here we filter on character data.\n\ncms_data |&gt; filter(hospital_type == \"Acute Care Hospital\")\n\n\nOutput\n\n\n# A tibble: 12 × 8\n   id     facility_name           county hospital_type star_rating no_of_surveys\n   &lt;chr&gt;  &lt;chr&gt;                   &lt;chr&gt;  &lt;chr&gt;               &lt;dbl&gt;         &lt;dbl&gt;\n 1 050424 SCRIPPS GREEN HOSPITAL  SAN D… Acute Care H…           4          3110\n 2 140103 ST BERNARD HOSPITAL     COOK   Acute Care H…           1           264\n 3 100051 SOUTH LAKE HOSPITAL     LAKE   Acute Care H…           2          1382\n 4 040062 MERCY HOSPITAL FORT SM… SEBAS… Acute Care H…           3          2506\n 5 440048 BAPTIST MEMORIAL HOSPI… SHELBY Acute Care H…           2          1799\n 6 450011 ST JOSEPH REGIONAL HEA… BRAZOS Acute Care H…           3          1379\n 7 490057 SENTARA GENERAL HOSPIT… VIRGI… Acute Care H…           4           619\n 8 110215 PIEDMONT FAYETTE HOSPI… FAYET… Acute Care H…           2          1714\n 9 050704 MISSION COMMUNITY HOSP… LOS A… Acute Care H…           3           241\n10 100296 DOCTORS HOSPITAL        MIAMI… Acute Care H…           4           393\n11 440003 SUMNER REGIONAL MEDICA… SUMNER Acute Care H…           4           680\n12 050116 NORTHRIDGE MEDICAL CEN… LOS A… Acute Care H…           3          1110\n# ℹ 2 more variables: response_rate &lt;dbl&gt;, overall_rating &lt;dbl&gt;\n\n\n\nWe can use logical operators introduced before to combine multiple conditions as follows.\nExample 3: Find all the facilities categorized as “Acute Care Hospital” and has a overall rating of above 3.\n\ncms_data |&gt; filter(hospital_type == \"Acute Care Hospital\" & overall_rating &gt; 3)\n\n\nOutput\n\n\n# A tibble: 1 × 8\n  id     facility_name          county   hospital_type star_rating no_of_surveys\n  &lt;chr&gt;  &lt;chr&gt;                  &lt;chr&gt;    &lt;chr&gt;               &lt;dbl&gt;         &lt;dbl&gt;\n1 050424 SCRIPPS GREEN HOSPITAL SAN DIE… Acute Care H…           4          3110\n# ℹ 2 more variables: response_rate &lt;dbl&gt;, overall_rating &lt;dbl&gt;\n\n\n\nExample 4: Find the facilities with any rating greater than or equal to 3.\n\ncms_data |&gt; filter(star_rating &gt;= 3 | overall_rating &gt;= 3)\n\n\nOutput\n\n\n# A tibble: 11 × 8\n   id     facility_name           county hospital_type star_rating no_of_surveys\n   &lt;chr&gt;  &lt;chr&gt;                   &lt;chr&gt;  &lt;chr&gt;               &lt;dbl&gt;         &lt;dbl&gt;\n 1 050424 SCRIPPS GREEN HOSPITAL  SAN D… Acute Care H…           4          3110\n 2 040062 MERCY HOSPITAL FORT SM… SEBAS… Acute Care H…           3          2506\n 3 450011 ST JOSEPH REGIONAL HEA… BRAZOS Acute Care H…           3          1379\n 4 151317 GREENE COUNTY GENERAL … GREENE Critical Acc…           3           114\n 5 061327 SOUTHWEST MEMORIAL HOS… MONTE… Critical Acc…           4           247\n 6 490057 SENTARA GENERAL HOSPIT… VIRGI… Acute Care H…           4           619\n 7 050704 MISSION COMMUNITY HOSP… LOS A… Acute Care H…           3           241\n 8 100296 DOCTORS HOSPITAL        MIAMI… Acute Care H…           4           393\n 9 440003 SUMNER REGIONAL MEDICA… SUMNER Acute Care H…           4           680\n10 501339 WHIDBEY GENERAL HOSPIT… ISLAND Critical Acc…           3           389\n11 050116 NORTHRIDGE MEDICAL CEN… LOS A… Acute Care H…           3          1110\n# ℹ 2 more variables: response_rate &lt;dbl&gt;, overall_rating &lt;dbl&gt;\n\n\n\nExample 5: Find the facilitites with any rating greater than or equal to 3 and the response rate is above 30.\n\ncms_data |&gt; filter(star_rating &gt;= 3 | overall_rating &gt;= 3 & response_rate &gt; 30)\n\n\nOutput\n\n\n# A tibble: 11 × 8\n   id     facility_name           county hospital_type star_rating no_of_surveys\n   &lt;chr&gt;  &lt;chr&gt;                   &lt;chr&gt;  &lt;chr&gt;               &lt;dbl&gt;         &lt;dbl&gt;\n 1 050424 SCRIPPS GREEN HOSPITAL  SAN D… Acute Care H…           4          3110\n 2 040062 MERCY HOSPITAL FORT SM… SEBAS… Acute Care H…           3          2506\n 3 450011 ST JOSEPH REGIONAL HEA… BRAZOS Acute Care H…           3          1379\n 4 151317 GREENE COUNTY GENERAL … GREENE Critical Acc…           3           114\n 5 061327 SOUTHWEST MEMORIAL HOS… MONTE… Critical Acc…           4           247\n 6 490057 SENTARA GENERAL HOSPIT… VIRGI… Acute Care H…           4           619\n 7 050704 MISSION COMMUNITY HOSP… LOS A… Acute Care H…           3           241\n 8 100296 DOCTORS HOSPITAL        MIAMI… Acute Care H…           4           393\n 9 440003 SUMNER REGIONAL MEDICA… SUMNER Acute Care H…           4           680\n10 501339 WHIDBEY GENERAL HOSPIT… ISLAND Critical Acc…           3           389\n11 050116 NORTHRIDGE MEDICAL CEN… LOS A… Acute Care H…           3          1110\n# ℹ 2 more variables: response_rate &lt;dbl&gt;, overall_rating &lt;dbl&gt;\n\n\n\nThe output of the above command is incorrect. Recall R operator precedence where & operator precedes | operator. Therefore, the command overall_rating &gt;= 3 & response_rate &gt; 30 is evaluated first. This can be verified by adding brackets around this command as follows: To fix the issue add brackets as follows:\n\ncms_data |&gt; filter(star_rating &gt;= 3 | (overall_rating &gt;= 3 & response_rate &gt; 30))\n\n\nOutput\n\n\n# A tibble: 11 × 8\n   id     facility_name           county hospital_type star_rating no_of_surveys\n   &lt;chr&gt;  &lt;chr&gt;                   &lt;chr&gt;  &lt;chr&gt;               &lt;dbl&gt;         &lt;dbl&gt;\n 1 050424 SCRIPPS GREEN HOSPITAL  SAN D… Acute Care H…           4          3110\n 2 040062 MERCY HOSPITAL FORT SM… SEBAS… Acute Care H…           3          2506\n 3 450011 ST JOSEPH REGIONAL HEA… BRAZOS Acute Care H…           3          1379\n 4 151317 GREENE COUNTY GENERAL … GREENE Critical Acc…           3           114\n 5 061327 SOUTHWEST MEMORIAL HOS… MONTE… Critical Acc…           4           247\n 6 490057 SENTARA GENERAL HOSPIT… VIRGI… Acute Care H…           4           619\n 7 050704 MISSION COMMUNITY HOSP… LOS A… Acute Care H…           3           241\n 8 100296 DOCTORS HOSPITAL        MIAMI… Acute Care H…           4           393\n 9 440003 SUMNER REGIONAL MEDICA… SUMNER Acute Care H…           4           680\n10 501339 WHIDBEY GENERAL HOSPIT… ISLAND Critical Acc…           3           389\n11 050116 NORTHRIDGE MEDICAL CEN… LOS A… Acute Care H…           3          1110\n# ℹ 2 more variables: response_rate &lt;dbl&gt;, overall_rating &lt;dbl&gt;\n\n\n\nTo fix the issue add brackets as follows:\n\ncms_data |&gt; filter((star_rating &gt;= 3 | overall_rating &gt;= 3) & response_rate &gt; 30)\n\n\nOutput\n\n\n# A tibble: 5 × 8\n  id     facility_name            county hospital_type star_rating no_of_surveys\n  &lt;chr&gt;  &lt;chr&gt;                    &lt;chr&gt;  &lt;chr&gt;               &lt;dbl&gt;         &lt;dbl&gt;\n1 050424 SCRIPPS GREEN HOSPITAL   SAN D… Acute Care H…           4          3110\n2 040062 MERCY HOSPITAL FORT SMI… SEBAS… Acute Care H…           3          2506\n3 061327 SOUTHWEST MEMORIAL HOSP… MONTE… Critical Acc…           4           247\n4 490057 SENTARA GENERAL HOSPITAL VIRGI… Acute Care H…           4           619\n5 440003 SUMNER REGIONAL MEDICAL… SUMNER Acute Care H…           4           680\n# ℹ 2 more variables: response_rate &lt;dbl&gt;, overall_rating &lt;dbl&gt;\n\n\n\nThis results in the correct output.\n\n%in% helper\nThe %in% function is used to determine whether elements of one vector are present in another vector. It returns a logical vector indicating whether each element of the first vector is found in the second vector.\nWhen we want to filter a subset of rows that may contain multiple different values, it’s more efficient to provide a vector of the values of interest instead of combining multiple OR commands.\nExample 6: Retrieve a subset of facilities that have an odd number of overall rating.\n\ncms_data |&gt; filter(overall_rating %in% c(1, 3, 5))\n\n\n  Output\n\n\n# A tibble: 9 × 8\n  id     facility_name            county hospital_type star_rating no_of_surveys\n  &lt;chr&gt;  &lt;chr&gt;                    &lt;chr&gt;  &lt;chr&gt;               &lt;dbl&gt;         &lt;dbl&gt;\n1 050424 SCRIPPS GREEN HOSPITAL   SAN D… Acute Care H…           4          3110\n2 040062 MERCY HOSPITAL FORT SMI… SEBAS… Acute Care H…           3          2506\n3 450011 ST JOSEPH REGIONAL HEAL… BRAZOS Acute Care H…           3          1379\n4 151317 GREENE COUNTY GENERAL H… GREENE Critical Acc…           3           114\n5 061327 SOUTHWEST MEMORIAL HOSP… MONTE… Critical Acc…           4           247\n6 490057 SENTARA GENERAL HOSPITAL VIRGI… Acute Care H…           4           619\n7 050704 MISSION COMMUNITY HOSPI… LOS A… Acute Care H…           3           241\n8 100296 DOCTORS HOSPITAL         MIAMI… Acute Care H…           4           393\n9 501339 WHIDBEY GENERAL HOSPITAL ISLAND Critical Acc…           3           389\n# ℹ 2 more variables: response_rate &lt;dbl&gt;, overall_rating &lt;dbl&gt;\n\n\n\n\n\nstr_detect function\nThe str_detect() function is part of the stringr package and is used for pattern matching within strings. It allows you to search for a specific pattern or regular expression (discussed later) within a character vector or string.\nExample 1: Find all the facilities that contains GENERAL in their name from the cms_data data frame.\n\ncms_data |&gt; filter(\n  str_detect(facility_name, 'GENERAL')\n  )\n\n\n  Output\n\n\n# A tibble: 3 × 8\n  id     facility_name            county hospital_type star_rating no_of_surveys\n  &lt;chr&gt;  &lt;chr&gt;                    &lt;chr&gt;  &lt;chr&gt;               &lt;dbl&gt;         &lt;dbl&gt;\n1 151317 GREENE COUNTY GENERAL H… GREENE Critical Acc…           3           114\n2 490057 SENTARA GENERAL HOSPITAL VIRGI… Acute Care H…           4           619\n3 501339 WHIDBEY GENERAL HOSPITAL ISLAND Critical Acc…           3           389\n# ℹ 2 more variables: response_rate &lt;dbl&gt;, overall_rating &lt;dbl&gt;\n\n\n\n\n\n\nselect()\nThe select() function returns a subset of the variables or columns.\n\n\n\n\n\nThis function can accept column names (even without quotation marks) or the column position number starting from the left. Unlike in base R (we explore before), commands within the brackets in select() do not need to be concatenated using c().\nExample 1: Extract the facility name, hospital type and overall rating columns from cms_data data frame.\n\ncms_data |&gt; select(facility_name, hospital_type, overall_rating)\n\n\nOutput\n\n\n# A tibble: 15 × 3\n   facility_name                    hospital_type            overall_rating\n   &lt;chr&gt;                            &lt;chr&gt;                             &lt;dbl&gt;\n 1 SCRIPPS GREEN HOSPITAL           Acute Care Hospital                   5\n 2 ST BERNARD HOSPITAL              Acute Care Hospital                   2\n 3 SOUTH LAKE HOSPITAL              Acute Care Hospital                   2\n 4 MERCY HOSPITAL FORT SMITH        Acute Care Hospital                   3\n 5 BAPTIST MEMORIAL HOSPITAL        Acute Care Hospital                   2\n 6 ST JOSEPH REGIONAL HEALTH CENTER Acute Care Hospital                   3\n 7 GREENE COUNTY GENERAL HOSPITAL   Critical Access Hospital              3\n 8 SOUTHWEST MEMORIAL HOSPITAL      Critical Access Hospital              3\n 9 SENTARA GENERAL HOSPITAL         Acute Care Hospital                   3\n10 PIEDMONT FAYETTE HOSPITAL        Acute Care Hospital                   2\n11 MISSION COMMUNITY HOSPITAL       Acute Care Hospital                   3\n12 DOCTORS HOSPITAL                 Acute Care Hospital                   3\n13 SUMNER REGIONAL MEDICAL CENTER   Acute Care Hospital                   2\n14 WHIDBEY GENERAL HOSPITAL         Critical Access Hospital              3\n15 NORTHRIDGE MEDICAL CENTER        Acute Care Hospital                   2\n\n\n\nUsing column positions:\n\ncms_data |&gt; select(2, 4, 8)\n\n\nOutput\n\n\n# A tibble: 15 × 3\n   facility_name                    hospital_type            overall_rating\n   &lt;chr&gt;                            &lt;chr&gt;                             &lt;dbl&gt;\n 1 SCRIPPS GREEN HOSPITAL           Acute Care Hospital                   5\n 2 ST BERNARD HOSPITAL              Acute Care Hospital                   2\n 3 SOUTH LAKE HOSPITAL              Acute Care Hospital                   2\n 4 MERCY HOSPITAL FORT SMITH        Acute Care Hospital                   3\n 5 BAPTIST MEMORIAL HOSPITAL        Acute Care Hospital                   2\n 6 ST JOSEPH REGIONAL HEALTH CENTER Acute Care Hospital                   3\n 7 GREENE COUNTY GENERAL HOSPITAL   Critical Access Hospital              3\n 8 SOUTHWEST MEMORIAL HOSPITAL      Critical Access Hospital              3\n 9 SENTARA GENERAL HOSPITAL         Acute Care Hospital                   3\n10 PIEDMONT FAYETTE HOSPITAL        Acute Care Hospital                   2\n11 MISSION COMMUNITY HOSPITAL       Acute Care Hospital                   3\n12 DOCTORS HOSPITAL                 Acute Care Hospital                   3\n13 SUMNER REGIONAL MEDICAL CENTER   Acute Care Hospital                   2\n14 WHIDBEY GENERAL HOSPITAL         Critical Access Hospital              3\n15 NORTHRIDGE MEDICAL CENTER        Acute Care Hospital                   2\n\n\n\nWe can use the ‘-’ symbol to extract all columns except for specific ones:\n\ncms_data |&gt; dplyr::select(-id, -county_name, -star_rating, -no_of_surveys, -response_rate)\n\n\nOutput\n\n\n# A tibble: 15 × 3\n   facility_name                    hospital_type            overall_rating\n   &lt;chr&gt;                            &lt;chr&gt;                             &lt;dbl&gt;\n 1 SCRIPPS GREEN HOSPITAL           Acute Care Hospital                   5\n 2 ST BERNARD HOSPITAL              Acute Care Hospital                   2\n 3 SOUTH LAKE HOSPITAL              Acute Care Hospital                   2\n 4 MERCY HOSPITAL FORT SMITH        Acute Care Hospital                   3\n 5 BAPTIST MEMORIAL HOSPITAL        Acute Care Hospital                   2\n 6 ST JOSEPH REGIONAL HEALTH CENTER Acute Care Hospital                   3\n 7 GREENE COUNTY GENERAL HOSPITAL   Critical Access Hospital              3\n 8 SOUTHWEST MEMORIAL HOSPITAL      Critical Access Hospital              3\n 9 SENTARA GENERAL HOSPITAL         Acute Care Hospital                   3\n10 PIEDMONT FAYETTE HOSPITAL        Acute Care Hospital                   2\n11 MISSION COMMUNITY HOSPITAL       Acute Care Hospital                   3\n12 DOCTORS HOSPITAL                 Acute Care Hospital                   3\n13 SUMNER REGIONAL MEDICAL CENTER   Acute Care Hospital                   2\n14 WHIDBEY GENERAL HOSPITAL         Critical Access Hospital              3\n15 NORTHRIDGE MEDICAL CENTER        Acute Care Hospital                   2\n\n\n\nOr use a combination of column names and positions:\n\ncms_data |&gt; select(2, 4, overall_rating)\n\n\nOutput\n\n\n# A tibble: 15 × 3\n   facility_name                    hospital_type            overall_rating\n   &lt;chr&gt;                            &lt;chr&gt;                             &lt;dbl&gt;\n 1 SCRIPPS GREEN HOSPITAL           Acute Care Hospital                   5\n 2 ST BERNARD HOSPITAL              Acute Care Hospital                   2\n 3 SOUTH LAKE HOSPITAL              Acute Care Hospital                   2\n 4 MERCY HOSPITAL FORT SMITH        Acute Care Hospital                   3\n 5 BAPTIST MEMORIAL HOSPITAL        Acute Care Hospital                   2\n 6 ST JOSEPH REGIONAL HEALTH CENTER Acute Care Hospital                   3\n 7 GREENE COUNTY GENERAL HOSPITAL   Critical Access Hospital              3\n 8 SOUTHWEST MEMORIAL HOSPITAL      Critical Access Hospital              3\n 9 SENTARA GENERAL HOSPITAL         Acute Care Hospital                   3\n10 PIEDMONT FAYETTE HOSPITAL        Acute Care Hospital                   2\n11 MISSION COMMUNITY HOSPITAL       Acute Care Hospital                   3\n12 DOCTORS HOSPITAL                 Acute Care Hospital                   3\n13 SUMNER REGIONAL MEDICAL CENTER   Acute Care Hospital                   2\n14 WHIDBEY GENERAL HOSPITAL         Critical Access Hospital              3\n15 NORTHRIDGE MEDICAL CENTER        Acute Care Hospital                   2\n\n\n\n\nUseful helper functions\nThe select helper functions (check ?select_helpers) are a set of convenience functions provided by the dplyr package. These functions offer shortcuts for selecting columns based on specific criteria or patterns, making it easier to work with data frames.\nSome commonly used select helper functions include:\n\nstarts_with(): selects columns that start with a specified prefix.\n\n\ncms_data |&gt; select(starts_with('s'))\n\n\nOutput\n\n\n# A tibble: 15 × 1\n   star_rating\n         &lt;dbl&gt;\n 1           4\n 2           1\n 3           2\n 4           3\n 5           2\n 6           3\n 7           3\n 8           4\n 9           4\n10           2\n11           3\n12           4\n13           4\n14           3\n15           3\n\n\n\n\nends_with(): selects columns that end with a specified suffix.\n\n\ncms_data |&gt; select(ends_with('g'))\n\n\nOutput\n\n\n# A tibble: 15 × 2\n   star_rating overall_rating\n         &lt;dbl&gt;          &lt;dbl&gt;\n 1           4              5\n 2           1              2\n 3           2              2\n 4           3              3\n 5           2              2\n 6           3              3\n 7           3              3\n 8           4              3\n 9           4              3\n10           2              2\n11           3              3\n12           4              3\n13           4              2\n14           3              3\n15           3              2\n\n\n\n\ncontains(): selects columns that contain a specified substring.\n\n\ncms_data |&gt; select(contains('name'))\n\n\nOutput\n\n\n# A tibble: 15 × 1\n   facility_name                   \n   &lt;chr&gt;                           \n 1 SCRIPPS GREEN HOSPITAL          \n 2 ST BERNARD HOSPITAL             \n 3 SOUTH LAKE HOSPITAL             \n 4 MERCY HOSPITAL FORT SMITH       \n 5 BAPTIST MEMORIAL HOSPITAL       \n 6 ST JOSEPH REGIONAL HEALTH CENTER\n 7 GREENE COUNTY GENERAL HOSPITAL  \n 8 SOUTHWEST MEMORIAL HOSPITAL     \n 9 SENTARA GENERAL HOSPITAL        \n10 PIEDMONT FAYETTE HOSPITAL       \n11 MISSION COMMUNITY HOSPITAL      \n12 DOCTORS HOSPITAL                \n13 SUMNER REGIONAL MEDICAL CENTER  \n14 WHIDBEY GENERAL HOSPITAL        \n15 NORTHRIDGE MEDICAL CENTER       \n\n\n\n\ncms_data |&gt; select(contains('f'))\n\n\nOutput\n\n\n# A tibble: 15 × 2\n   facility_name                    no_of_surveys\n   &lt;chr&gt;                                    &lt;dbl&gt;\n 1 SCRIPPS GREEN HOSPITAL                    3110\n 2 ST BERNARD HOSPITAL                        264\n 3 SOUTH LAKE HOSPITAL                       1382\n 4 MERCY HOSPITAL FORT SMITH                 2506\n 5 BAPTIST MEMORIAL HOSPITAL                 1799\n 6 ST JOSEPH REGIONAL HEALTH CENTER          1379\n 7 GREENE COUNTY GENERAL HOSPITAL             114\n 8 SOUTHWEST MEMORIAL HOSPITAL                247\n 9 SENTARA GENERAL HOSPITAL                   619\n10 PIEDMONT FAYETTE HOSPITAL                 1714\n11 MISSION COMMUNITY HOSPITAL                 241\n12 DOCTORS HOSPITAL                           393\n13 SUMNER REGIONAL MEDICAL CENTER             680\n14 WHIDBEY GENERAL HOSPITAL                   389\n15 NORTHRIDGE MEDICAL CENTER                 1110\n\n\n\n\nmatches(): selects columns that match a specified regular expression pattern.\n\n\ncms_data |&gt; select(\n  matches('[a-z]_[a-z]{4}$')\n  )\n\n\nOutput\n\n\n# A tibble: 15 × 3\n   facility_name                    hospital_type            response_rate\n   &lt;chr&gt;                            &lt;chr&gt;                            &lt;dbl&gt;\n 1 SCRIPPS GREEN HOSPITAL           Acute Care Hospital                 41\n 2 ST BERNARD HOSPITAL              Acute Care Hospital                  6\n 3 SOUTH LAKE HOSPITAL              Acute Care Hospital                 20\n 4 MERCY HOSPITAL FORT SMITH        Acute Care Hospital                 35\n 5 BAPTIST MEMORIAL HOSPITAL        Acute Care Hospital                 18\n 6 ST JOSEPH REGIONAL HEALTH CENTER Acute Care Hospital                 24\n 7 GREENE COUNTY GENERAL HOSPITAL   Critical Access Hospital            22\n 8 SOUTHWEST MEMORIAL HOSPITAL      Critical Access Hospital            34\n 9 SENTARA GENERAL HOSPITAL         Acute Care Hospital                 32\n10 PIEDMONT FAYETTE HOSPITAL        Acute Care Hospital                 21\n11 MISSION COMMUNITY HOSPITAL       Acute Care Hospital                 14\n12 DOCTORS HOSPITAL                 Acute Care Hospital                 24\n13 SUMNER REGIONAL MEDICAL CENTER   Acute Care Hospital                 35\n14 WHIDBEY GENERAL HOSPITAL         Critical Access Hospital            29\n15 NORTHRIDGE MEDICAL CENTER        Acute Care Hospital                 20\n\n\n\nHere, the regular expression [a-z]_[a-z]{4}$ can be broken down into smaller chunks for better understanding:\n\n[a-z] matches a set of lowercase characters from ‘a’ to ‘z’.\n_ matches an underscore.\n[a-z]{4} matches any four lowercase characters from ‘a’ to ‘z’.\n\nPutting this together, the expression selects column names that have four characters after an underscore. Thus, it should match column names: facility_name, county_name, hospital_type, and response_rate.\nIf you’re unfamiliar with regular expressions, you can skip this section for now. However, interested readers can find many online resources to learn about regular expressions. One of my favorite online tools for building and testing regular expressions is https://regexr.com. You can use this tool to test the correctness of a regular expression.\n\nnum_range(): selects columns based on a numeric range.\n\nLet’s use the count data frame for this example. First read the csv file: GSE60450_normalized_data.csv.\n\ncounts &lt;- read_csv(\"data/GSE60450_normalized_data.csv\")\ncolnames(counts)\n\n\nOutput\n\n\nRows: 20 Columns: 14\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): X, gene_symbol\ndbl (12): GSM1480291, GSM1480292, GSM1480293, GSM1480294, GSM1480295, GSM148...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n [1] \"X\"           \"gene_symbol\" \"GSM1480291\"  \"GSM1480292\"  \"GSM1480293\" \n [6] \"GSM1480294\"  \"GSM1480295\"  \"GSM1480296\"  \"GSM1480297\"  \"GSM1480298\" \n[11] \"GSM1480299\"  \"GSM1480300\"  \"GSM1480301\"  \"GSM1480302\" \n\n\n\nTo select the samples from GSM1480297 to GSM1480300:\n\ncounts |&gt; select(\n  num_range(prefix = \"GSM1480\", 297:300)\n  )\n\n\nOutput\n\n\n# A tibble: 20 × 4\n   GSM1480297 GSM1480298 GSM1480299 GSM1480300\n        &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n 1    10.6       14.9        7.57       7.06  \n 2    95.7      101.        78.1       59.4   \n 3     0          0          0          0     \n 4   125.       103.       111.        98.0   \n 5     0          0.0850     0.0773     0.0826\n 6    33.8       36.9       27.5       31.4   \n 7     0          0          0          0     \n 8   282.       242.       228.       233.    \n 9    62.6       61.8       50.0       42.0   \n10    18.0       13.7        9.00       9.70  \n11    51.8       49.5       52.8       47.0   \n12    50.1       50.9       45.0       36.9   \n13   148.       128.       168.       133.    \n14    52.8       84.7      324.       486.    \n15     0.0799     0          0          0     \n16     0          0          0.0386     0     \n17   102.        81.1      115.       138.    \n18     0.0400     0          0          0     \n19     0          0          0          0     \n20    14.0       11.6       12.1       12.2   \n\n\n\n\nall_of(): selects columns specified by character vector.\n\n\ncms_data |&gt; select(\n  all_of(c(\"star_rating\", \"no_of_surveys\", \"response_rate\", \"no_column_by_this_name\"))\n  )\n\nError in `all_of()`:\n! Can't subset columns that don't exist.\n✖ Column `no_column_by_this_name` doesn't exist.\n\n\nWhen using all_of(), all the names provided by the vector must be present in the data frame. Otherwise, it will result in an error, as shown above.\n\ncms_data |&gt; select(\n  all_of(c(\"star_rating\", \"no_of_surveys\", \"response_rate\"))\n  )\n\n\nOutput\n\n\n# A tibble: 15 × 3\n   star_rating no_of_surveys response_rate\n         &lt;dbl&gt;         &lt;dbl&gt;         &lt;dbl&gt;\n 1           4          3110            41\n 2           1           264             6\n 3           2          1382            20\n 4           3          2506            35\n 5           2          1799            18\n 6           3          1379            24\n 7           3           114            22\n 8           4           247            34\n 9           4           619            32\n10           2          1714            21\n11           3           241            14\n12           4           393            24\n13           4           680            35\n14           3           389            29\n15           3          1110            20\n\n\n\n\nany_of(): selects columns specified by character vector, allowing any of them to be present.\n\n\ncms_data |&gt; select(\n  any_of(c(\"star_rating\", \"no_of_surveys\", \"response_rate\", \"no_column_by_this_name\"))\n  )\n\n\nOutput\n\n\n# A tibble: 15 × 3\n   star_rating no_of_surveys response_rate\n         &lt;dbl&gt;         &lt;dbl&gt;         &lt;dbl&gt;\n 1           4          3110            41\n 2           1           264             6\n 3           2          1382            20\n 4           3          2506            35\n 5           2          1799            18\n 6           3          1379            24\n 7           3           114            22\n 8           4           247            34\n 9           4           619            32\n10           2          1714            21\n11           3           241            14\n12           4           393            24\n13           4           680            35\n14           3           389            29\n15           3          1110            20\n\n\n\n\neverything(): Selects all columns.\n\nThis function returns all column names that have not been specified. It is often used when reordering all columns in a dataframe:\n\ncms_data |&gt; select(5, 8, 2, everything())\n\n\nOutput\n\n\n# A tibble: 15 × 8\n   star_rating overall_rating facility_name           id    county hospital_type\n         &lt;dbl&gt;          &lt;dbl&gt; &lt;chr&gt;                   &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;        \n 1           4              5 SCRIPPS GREEN HOSPITAL  0504… SAN D… Acute Care H…\n 2           1              2 ST BERNARD HOSPITAL     1401… COOK   Acute Care H…\n 3           2              2 SOUTH LAKE HOSPITAL     1000… LAKE   Acute Care H…\n 4           3              3 MERCY HOSPITAL FORT SM… 0400… SEBAS… Acute Care H…\n 5           2              2 BAPTIST MEMORIAL HOSPI… 4400… SHELBY Acute Care H…\n 6           3              3 ST JOSEPH REGIONAL HEA… 4500… BRAZOS Acute Care H…\n 7           3              3 GREENE COUNTY GENERAL … 1513… GREENE Critical Acc…\n 8           4              3 SOUTHWEST MEMORIAL HOS… 0613… MONTE… Critical Acc…\n 9           4              3 SENTARA GENERAL HOSPIT… 4900… VIRGI… Acute Care H…\n10           2              2 PIEDMONT FAYETTE HOSPI… 1102… FAYET… Acute Care H…\n11           3              3 MISSION COMMUNITY HOSP… 0507… LOS A… Acute Care H…\n12           4              3 DOCTORS HOSPITAL        1002… MIAMI… Acute Care H…\n13           4              2 SUMNER REGIONAL MEDICA… 4400… SUMNER Acute Care H…\n14           3              3 WHIDBEY GENERAL HOSPIT… 5013… ISLAND Critical Acc…\n15           3              2 NORTHRIDGE MEDICAL CEN… 0501… LOS A… Acute Care H…\n# ℹ 2 more variables: no_of_surveys &lt;dbl&gt;, response_rate &lt;dbl&gt;\n\n\n\nHere the dimensions of the dataframe is not changed, merely the column order.\n\nYou can combine multiple helper functions to create more complex selection criteria. Additionally, you can use the ‘-’ symbol in front of the helper function to exclude the matched columns.\n\nFor example try the following examples:\n\ncms_data |&gt; select(starts_with('i'), contains('rating'))\ncms_data |&gt; select(ends_with(\"type\"), everything(), -1, -3)\n\n\n\n\nmutate()\nThe mutate() function adds new columns of data, thus ‘mutating’ the contents and dimensions of the input data frame.\n\nExample 1: Calculate the total number of patients or visitors who responded to the survey in each facility (i.e, \\(\\text{response rate } = \\frac{\\text{number of responses}}{\\text{total number of surveys}} \\times 100\\)).\nHere we use the round() function to round off the result to the closest integer or numeric value as number of responses cannot contain decimal values.\n\ncms_data |&gt; \n  mutate(no_of_responses = round(no_of_surveys * response_rate / 100))\n\n\nOutput\n\n\n# A tibble: 15 × 9\n   id     facility_name           county hospital_type star_rating no_of_surveys\n   &lt;chr&gt;  &lt;chr&gt;                   &lt;chr&gt;  &lt;chr&gt;               &lt;dbl&gt;         &lt;dbl&gt;\n 1 050424 SCRIPPS GREEN HOSPITAL  SAN D… Acute Care H…           4          3110\n 2 140103 ST BERNARD HOSPITAL     COOK   Acute Care H…           1           264\n 3 100051 SOUTH LAKE HOSPITAL     LAKE   Acute Care H…           2          1382\n 4 040062 MERCY HOSPITAL FORT SM… SEBAS… Acute Care H…           3          2506\n 5 440048 BAPTIST MEMORIAL HOSPI… SHELBY Acute Care H…           2          1799\n 6 450011 ST JOSEPH REGIONAL HEA… BRAZOS Acute Care H…           3          1379\n 7 151317 GREENE COUNTY GENERAL … GREENE Critical Acc…           3           114\n 8 061327 SOUTHWEST MEMORIAL HOS… MONTE… Critical Acc…           4           247\n 9 490057 SENTARA GENERAL HOSPIT… VIRGI… Acute Care H…           4           619\n10 110215 PIEDMONT FAYETTE HOSPI… FAYET… Acute Care H…           2          1714\n11 050704 MISSION COMMUNITY HOSP… LOS A… Acute Care H…           3           241\n12 100296 DOCTORS HOSPITAL        MIAMI… Acute Care H…           4           393\n13 440003 SUMNER REGIONAL MEDICA… SUMNER Acute Care H…           4           680\n14 501339 WHIDBEY GENERAL HOSPIT… ISLAND Critical Acc…           3           389\n15 050116 NORTHRIDGE MEDICAL CEN… LOS A… Acute Care H…           3          1110\n# ℹ 3 more variables: response_rate &lt;dbl&gt;, overall_rating &lt;dbl&gt;,\n#   no_of_responses &lt;dbl&gt;\n\n\n\nThis creates a new column at the end of the data frame named ‘no_of_responses’ and computes the total number of responses. Because the number of columns is expanding, we can reduce the number of columns displayed using the select() function.\nTo do this, we need to use chaining which is discussed below.\n\n\nChaining functions\nR chaining allows you to streamline your data analysis workflow by sequentially applying multiple operations to your data using the pipe operator |&gt;. We often need to perform several data manipulation or analysis operations in a sequence. Chaining allows you to apply these operations one after the other in a clear and concise manner.\nHere’s a basic template for chaining operations using the pipe operator |&gt;:\n\nresult &lt;- data |&gt;\n    operation1(...) |&gt;\n    operation2(...) |&gt;\n    operation3(...) |&gt;\n    ...\n    operationN(...)\n\nIn this template:\n\ndata represents the input data frame or object.\noperation1, operation2, …, operationN represent the functions or operations you want to apply sequentially to the data.For example: select(), filter() or mutate() functions.\n... represents any additional arguments or parameters that may be passed to each operation.\n\nEach operation takes the output of the previous operation as its input, making it easy to chain multiple operations together. This improves the readability of your code by organizing operations in a left-to-right fashion and it avoids creating intermediate variables to store the results of each operation.\n\n\nmutate() continued\nLet’s use chaining to combine both select() and mutate() operations for the previos example:\n\ncms_data |&gt; \n  select(facility_name, no_of_surveys, response_rate) |&gt; \n  mutate(no_of_responses = round(no_of_surveys * response_rate / 100))\n\n\nOutput\n\n\n# A tibble: 15 × 4\n   facility_name                    no_of_surveys response_rate no_of_responses\n   &lt;chr&gt;                                    &lt;dbl&gt;         &lt;dbl&gt;           &lt;dbl&gt;\n 1 SCRIPPS GREEN HOSPITAL                    3110            41          127510\n 2 ST BERNARD HOSPITAL                        264             6            1584\n 3 SOUTH LAKE HOSPITAL                       1382            20           27640\n 4 MERCY HOSPITAL FORT SMITH                 2506            35           87710\n 5 BAPTIST MEMORIAL HOSPITAL                 1799            18           32382\n 6 ST JOSEPH REGIONAL HEALTH CENTER          1379            24           33096\n 7 GREENE COUNTY GENERAL HOSPITAL             114            22            2508\n 8 SOUTHWEST MEMORIAL HOSPITAL                247            34            8398\n 9 SENTARA GENERAL HOSPITAL                   619            32           19808\n10 PIEDMONT FAYETTE HOSPITAL                 1714            21           35994\n11 MISSION COMMUNITY HOSPITAL                 241            14            3374\n12 DOCTORS HOSPITAL                           393            24            9432\n13 SUMNER REGIONAL MEDICAL CENTER             680            35           23800\n14 WHIDBEY GENERAL HOSPITAL                   389            29           11281\n15 NORTHRIDGE MEDICAL CENTER                 1110            20           22200\n\n\n\n\n\nsummarise()\nThe summarise() function creates individual summary statistics from larger data sets.\n\nThe output of summarise()/summarize() differs qualitatively from the input. It results in a smaller dataframe with a reduced representation of the original data. While not strictly necessary, it’s advisable to assign new column names for the summary statistics generated by this function. This practice enhances clarity and organization in your data analysis workflow.\nExample 1: Calculate the mean number of surveys.\n\ncms_data |&gt; \n  summarise(mean_no_of_surveys = mean(no_of_surveys))\n\n\nOutput\n\n\n# A tibble: 1 × 1\n  mean_no_of_surveys\n               &lt;dbl&gt;\n1              1063.\n\n\n\nThis results in a data frame of size 1 row \\(\\times\\) 1 col. We can create additional summary statistics by adding them in a comma-separated sequence as follows:\n\ncms_data |&gt; \n  summarise(mean_no_of_surveys = mean(no_of_surveys),\n            min_no_of_surveys = min(no_of_surveys),\n            max_no_of_surveys = max(no_of_surveys),\n            tot_no_of_surveys = sum(no_of_surveys))\n\n\nOutput\n\n\n# A tibble: 1 × 4\n  mean_no_of_surveys min_no_of_surveys max_no_of_surveys tot_no_of_surveys\n               &lt;dbl&gt;             &lt;dbl&gt;             &lt;dbl&gt;             &lt;dbl&gt;\n1              1063.               114              3110             15947\n\n\n\n\nn() helper function\nThis function counts the number of observations in a dataset. It does not take any arguments, but simply counts the rows.\n\ncms_data |&gt; \n  summarise(mean_no_of_surveys = mean(no_of_surveys),\n            min_no_of_surveys = min(no_of_surveys),\n            max_no_of_surveys = max(no_of_surveys),\n            tot_no_of_surveys = sum(no_of_surveys),\n            n_rows = n())\n\n\nOutput\n\n\n# A tibble: 1 × 5\n  mean_no_of_surveys min_no_of_surveys max_no_of_surveys tot_no_of_surveys\n               &lt;dbl&gt;             &lt;dbl&gt;             &lt;dbl&gt;             &lt;dbl&gt;\n1              1063.               114              3110             15947\n# ℹ 1 more variable: n_rows &lt;int&gt;\n\n\n\n\n\n\narrange()\nThe arrange() function orders rows based on the values in a given column.\n\nExample 1: Order the facilities based on the county.\n\ncms_data |&gt; \n  arrange(county)\n\n\nOutput\n\n\n# A tibble: 15 × 8\n   id     facility_name           county hospital_type star_rating no_of_surveys\n   &lt;chr&gt;  &lt;chr&gt;                   &lt;chr&gt;  &lt;chr&gt;               &lt;dbl&gt;         &lt;dbl&gt;\n 1 450011 ST JOSEPH REGIONAL HEA… BRAZOS Acute Care H…           3          1379\n 2 140103 ST BERNARD HOSPITAL     COOK   Acute Care H…           1           264\n 3 110215 PIEDMONT FAYETTE HOSPI… FAYET… Acute Care H…           2          1714\n 4 151317 GREENE COUNTY GENERAL … GREENE Critical Acc…           3           114\n 5 501339 WHIDBEY GENERAL HOSPIT… ISLAND Critical Acc…           3           389\n 6 100051 SOUTH LAKE HOSPITAL     LAKE   Acute Care H…           2          1382\n 7 050704 MISSION COMMUNITY HOSP… LOS A… Acute Care H…           3           241\n 8 050116 NORTHRIDGE MEDICAL CEN… LOS A… Acute Care H…           3          1110\n 9 100296 DOCTORS HOSPITAL        MIAMI… Acute Care H…           4           393\n10 061327 SOUTHWEST MEMORIAL HOS… MONTE… Critical Acc…           4           247\n11 050424 SCRIPPS GREEN HOSPITAL  SAN D… Acute Care H…           4          3110\n12 040062 MERCY HOSPITAL FORT SM… SEBAS… Acute Care H…           3          2506\n13 440048 BAPTIST MEMORIAL HOSPI… SHELBY Acute Care H…           2          1799\n14 440003 SUMNER REGIONAL MEDICA… SUMNER Acute Care H…           4           680\n15 490057 SENTARA GENERAL HOSPIT… VIRGI… Acute Care H…           4           619\n# ℹ 2 more variables: response_rate &lt;dbl&gt;, overall_rating &lt;dbl&gt;\n\n\n\nExample 2: Sort the facilities based on the overall rating first and then by response rate.\n\ncms_data |&gt; \n  arrange(overall_rating, response_rate)\n\n\nOutput\n\n\n# A tibble: 15 × 8\n   id     facility_name           county hospital_type star_rating no_of_surveys\n   &lt;chr&gt;  &lt;chr&gt;                   &lt;chr&gt;  &lt;chr&gt;               &lt;dbl&gt;         &lt;dbl&gt;\n 1 140103 ST BERNARD HOSPITAL     COOK   Acute Care H…           1           264\n 2 440048 BAPTIST MEMORIAL HOSPI… SHELBY Acute Care H…           2          1799\n 3 100051 SOUTH LAKE HOSPITAL     LAKE   Acute Care H…           2          1382\n 4 050116 NORTHRIDGE MEDICAL CEN… LOS A… Acute Care H…           3          1110\n 5 110215 PIEDMONT FAYETTE HOSPI… FAYET… Acute Care H…           2          1714\n 6 440003 SUMNER REGIONAL MEDICA… SUMNER Acute Care H…           4           680\n 7 050704 MISSION COMMUNITY HOSP… LOS A… Acute Care H…           3           241\n 8 151317 GREENE COUNTY GENERAL … GREENE Critical Acc…           3           114\n 9 450011 ST JOSEPH REGIONAL HEA… BRAZOS Acute Care H…           3          1379\n10 100296 DOCTORS HOSPITAL        MIAMI… Acute Care H…           4           393\n11 501339 WHIDBEY GENERAL HOSPIT… ISLAND Critical Acc…           3           389\n12 490057 SENTARA GENERAL HOSPIT… VIRGI… Acute Care H…           4           619\n13 061327 SOUTHWEST MEMORIAL HOS… MONTE… Critical Acc…           4           247\n14 040062 MERCY HOSPITAL FORT SM… SEBAS… Acute Care H…           3          2506\n15 050424 SCRIPPS GREEN HOSPITAL  SAN D… Acute Care H…           4          3110\n# ℹ 2 more variables: response_rate &lt;dbl&gt;, overall_rating &lt;dbl&gt;\n\n\n\n\ndesc() helper function\nThis function is used to sort data in descending order.\nExample 3: Sort the facilities in descending order based on the number of surveys\n\ncms_data |&gt; \n  arrange(desc(no_of_surveys))\n\n\nOutput\n\n\n# A tibble: 15 × 8\n   id     facility_name           county hospital_type star_rating no_of_surveys\n   &lt;chr&gt;  &lt;chr&gt;                   &lt;chr&gt;  &lt;chr&gt;               &lt;dbl&gt;         &lt;dbl&gt;\n 1 050424 SCRIPPS GREEN HOSPITAL  SAN D… Acute Care H…           4          3110\n 2 040062 MERCY HOSPITAL FORT SM… SEBAS… Acute Care H…           3          2506\n 3 440048 BAPTIST MEMORIAL HOSPI… SHELBY Acute Care H…           2          1799\n 4 110215 PIEDMONT FAYETTE HOSPI… FAYET… Acute Care H…           2          1714\n 5 100051 SOUTH LAKE HOSPITAL     LAKE   Acute Care H…           2          1382\n 6 450011 ST JOSEPH REGIONAL HEA… BRAZOS Acute Care H…           3          1379\n 7 050116 NORTHRIDGE MEDICAL CEN… LOS A… Acute Care H…           3          1110\n 8 440003 SUMNER REGIONAL MEDICA… SUMNER Acute Care H…           4           680\n 9 490057 SENTARA GENERAL HOSPIT… VIRGI… Acute Care H…           4           619\n10 100296 DOCTORS HOSPITAL        MIAMI… Acute Care H…           4           393\n11 501339 WHIDBEY GENERAL HOSPIT… ISLAND Critical Acc…           3           389\n12 140103 ST BERNARD HOSPITAL     COOK   Acute Care H…           1           264\n13 061327 SOUTHWEST MEMORIAL HOS… MONTE… Critical Acc…           4           247\n14 050704 MISSION COMMUNITY HOSP… LOS A… Acute Care H…           3           241\n15 151317 GREENE COUNTY GENERAL … GREENE Critical Acc…           3           114\n# ℹ 2 more variables: response_rate &lt;dbl&gt;, overall_rating &lt;dbl&gt;\n\n\n\n\n\n\ngroup_by()\nThe group_by() function groups data by one or more variables. It allows us to create sub groups based on labels in a particular column and to run subsequent functions or operations on all sub groups.\n\nThe group_by() function essentially partitions the data into separate subsets, each corresponding to a distinct category in a specified column. To observe this in action, inspect the structure using str() of the cms_data dataset before and after grouping:\n\ncms_data |&gt; str()\n\n\n  Output\n\n\nspc_tbl_ [15 × 8] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ id            : chr [1:15] \"050424\" \"140103\" \"100051\" \"040062\" ...\n $ facility_name : chr [1:15] \"SCRIPPS GREEN HOSPITAL\" \"ST BERNARD HOSPITAL\" \"SOUTH LAKE HOSPITAL\" \"MERCY HOSPITAL FORT SMITH\" ...\n $ county        : chr [1:15] \"SAN DIEGO\" \"COOK\" \"LAKE\" \"SEBASTIAN\" ...\n $ hospital_type : chr [1:15] \"Acute Care Hospital\" \"Acute Care Hospital\" \"Acute Care Hospital\" \"Acute Care Hospital\" ...\n $ star_rating   : num [1:15] 4 1 2 3 2 3 3 4 4 2 ...\n $ no_of_surveys : num [1:15] 3110 264 1382 2506 1799 ...\n $ response_rate : num [1:15] 41 6 20 35 18 24 22 34 32 21 ...\n $ overall_rating: num [1:15] 5 2 2 3 2 3 3 3 3 2 ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   ID = col_character(),\n  ..   `Facility Name` = col_character(),\n  ..   County = col_character(),\n  ..   `Hospital Type` = col_character(),\n  ..   `Star Rating` = col_double(),\n  ..   `No of Surveys` = col_double(),\n  ..   `Response Rate` = col_double(),\n  ..   `Overall Rating` = col_double()\n  .. )\n - attr(*, \"problems\")=&lt;externalptr&gt; \n\n\n\n\ncms_data |&gt; group_by(hospital_type) |&gt; str()\n\n\n  Output\n\n\ngropd_df [15 × 8] (S3: grouped_df/tbl_df/tbl/data.frame)\n $ id            : chr [1:15] \"050424\" \"140103\" \"100051\" \"040062\" ...\n $ facility_name : chr [1:15] \"SCRIPPS GREEN HOSPITAL\" \"ST BERNARD HOSPITAL\" \"SOUTH LAKE HOSPITAL\" \"MERCY HOSPITAL FORT SMITH\" ...\n $ county        : chr [1:15] \"SAN DIEGO\" \"COOK\" \"LAKE\" \"SEBASTIAN\" ...\n $ hospital_type : chr [1:15] \"Acute Care Hospital\" \"Acute Care Hospital\" \"Acute Care Hospital\" \"Acute Care Hospital\" ...\n $ star_rating   : num [1:15] 4 1 2 3 2 3 3 4 4 2 ...\n $ no_of_surveys : num [1:15] 3110 264 1382 2506 1799 ...\n $ response_rate : num [1:15] 41 6 20 35 18 24 22 34 32 21 ...\n $ overall_rating: num [1:15] 5 2 2 3 2 3 3 3 3 2 ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   ID = col_character(),\n  ..   `Facility Name` = col_character(),\n  ..   County = col_character(),\n  ..   `Hospital Type` = col_character(),\n  ..   `Star Rating` = col_double(),\n  ..   `No of Surveys` = col_double(),\n  ..   `Response Rate` = col_double(),\n  ..   `Overall Rating` = col_double()\n  .. )\n - attr(*, \"problems\")=&lt;externalptr&gt; \n - attr(*, \"groups\")= tibble [2 × 2] (S3: tbl_df/tbl/data.frame)\n  ..$ hospital_type: chr [1:2] \"Acute Care Hospital\" \"Critical Access Hospital\"\n  ..$ .rows        : list&lt;int&gt; [1:2] \n  .. ..$ : int [1:12] 1 2 3 4 5 6 9 10 11 12 ...\n  .. ..$ : int [1:3] 7 8 14\n  .. ..@ ptype: int(0) \n  ..- attr(*, \".drop\")= logi TRUE\n\n\n\nThe result of applying group_by() is a ‘grouped_df’ (grouped data frame) and all subsequent functions are executed independently on each subgroup of the data.\n\nungroup() helper\nThe ungroup() function is used to remove grouping from a data frame or a grouped data frame created using the group_by() function.\nWhen you apply group_by() to a data frame, it creates a grouped data frame where operations like summarization or manipulation are performed within each group defined by the grouping variables. However, in some cases, you may want to remove the grouping structure and return to the original ungrouped data frame. This is where the ungroup() function comes into play.\n\n\n\nCombining multiple dplyr functions\nIn this section, we will be using the Australian_Cancer_Incidence_and_Mortality.csv dataset.\n\ncancer_mort &lt;- read_csv(\"data/Australian_Cancer_Incidence_and_Mortality.csv\")\n\nFirst, let’s examine the dimensions of this dataset.\n\ndim(cancer_mort)\n\n\n  Output\n\n\n[1] 119862      6\n\n\n\nNext, let’s take a look at the top few rows of this data frame.\n\nhead(cancer_mort)\n\n\n  Output\n\n\n# A tibble: 6 × 6\n   Year Sex   Type      Cancer_Type                   Age   Count\n  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;                         &lt;chr&gt; &lt;dbl&gt;\n1  1982 Male  Incidence Acute lymphoblastic leukaemia 0-4      42\n2  1982 Male  Incidence Acute lymphoblastic leukaemia 5-9      25\n3  1982 Male  Incidence Acute lymphoblastic leukaemia 10-14    14\n4  1982 Male  Incidence Acute lymphoblastic leukaemia 15-19    14\n5  1982 Male  Incidence Acute lymphoblastic leukaemia 20-24     5\n6  1982 Male  Incidence Acute lymphoblastic leukaemia 25-29     2\n\n\n\n\ncount() helper\nThe count() function is used to count the number of occurrences of unique values in one or more variables within a data frame. This function is particularly useful for summarizing data and understanding the distribution of values within a dataset.\nIt is a convenient function that combines group_by() and summarize() in one step, particularly useful for counting occurrences of character data.\nExample 1: Count the number of cancers observed in each cancer type.\n\ncancer_mort |&gt; count(Cancer_Type)\n\n\nOutput\n\n\n# A tibble: 35 × 2\n   Cancer_Type                       n\n   &lt;chr&gt;                         &lt;int&gt;\n 1 Acute lymphoblastic leukaemia  3942\n 2 Acute myeloid leukaemia        3942\n 3 Anal cancer                    3942\n 4 Bladder cancer                 3942\n 5 Bowel cancer                   3942\n 6 Brain cancer                   3942\n 7 Breast cancer                  3942\n 8 Cervical cancer                1314\n 9 Chronic lymphocytic leukaemia  3942\n10 Chronic myeloid leukaemia      3942\n# ℹ 25 more rows\n\n\n\nIn the count summary output column is typically denoted as ‘n’. The same output can be observed by combining group_by() and summarise() functions as follows.\n\ncancer_mort |&gt; \n  group_by(Cancer_Type) |&gt; \n  summarise(n = n())\n\n\nOutput\n\n\n# A tibble: 35 × 2\n   Cancer_Type                       n\n   &lt;chr&gt;                         &lt;int&gt;\n 1 Acute lymphoblastic leukaemia  3942\n 2 Acute myeloid leukaemia        3942\n 3 Anal cancer                    3942\n 4 Bladder cancer                 3942\n 5 Bowel cancer                   3942\n 6 Brain cancer                   3942\n 7 Breast cancer                  3942\n 8 Cervical cancer                1314\n 9 Chronic lymphocytic leukaemia  3942\n10 Chronic myeloid leukaemia      3942\n# ℹ 25 more rows\n\n\n\nExample 2: Count the number of cancers observed in each cancer type and age group.\n\ncancer_mort |&gt; count(Cancer_Type, Age)\n\n\nOutput\n\n\n# A tibble: 630 × 3\n   Cancer_Type                   Age       n\n   &lt;chr&gt;                         &lt;chr&gt; &lt;int&gt;\n 1 Acute lymphoblastic leukaemia 0-4     219\n 2 Acute lymphoblastic leukaemia 10-14   219\n 3 Acute lymphoblastic leukaemia 15-19   219\n 4 Acute lymphoblastic leukaemia 20-24   219\n 5 Acute lymphoblastic leukaemia 25-29   219\n 6 Acute lymphoblastic leukaemia 30-34   219\n 7 Acute lymphoblastic leukaemia 35-39   219\n 8 Acute lymphoblastic leukaemia 40-44   219\n 9 Acute lymphoblastic leukaemia 45-49   219\n10 Acute lymphoblastic leukaemia 5-9     219\n# ℹ 620 more rows\n\n\n\n\n\nsample_n() helper\nThe sample_n() function is used to randomly select a specified number of rows from a data frame.\nExample 1: Sample 10 rows from the cancer_mort dataset.\n\ncancer_mort |&gt; sample_n(10)\n\n\nOutput\n\n\n# A tibble: 10 × 6\n    Year Sex     Type      Cancer_Type          Age   Count\n   &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;     &lt;chr&gt;                &lt;chr&gt; &lt;dbl&gt;\n 1  1987 Persons Mortality Brain cancer         55-59    69\n 2  1994 Male    Mortality Bladder cancer       25-29     0\n 3  1979 Female  Mortality Uterine cancer       80-84    28\n 4  1989 Female  Mortality Laryngeal cancer     60-64     7\n 5  2002 Persons Incidence Non-Hodgkin lymphoma 75-79   486\n 6  1993 Male    Incidence Prostate cancer      20-24     0\n 7  1999 Persons Incidence Pancreatic cancer    50-54    86\n 8  1970 Persons Mortality Unknown primary site 60-64    78\n 9  1991 Female  Mortality Kidney cancer        70-74    39\n10  1990 Female  Mortality Cervical cancer      0-4       0\n\n\n\nExample 2: Sample 3 rows randomly from each cancer type.\n\ncancer_mort |&gt; \n  group_by(Cancer_Type) |&gt; \n  sample_n(3)\n\n\nOutput\n\n\n# A tibble: 105 × 6\n# Groups:   Cancer_Type [35]\n    Year Sex     Type      Cancer_Type                   Age   Count\n   &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;     &lt;chr&gt;                         &lt;chr&gt; &lt;dbl&gt;\n 1  2001 Male    Mortality Acute lymphoblastic leukaemia 75-79     0\n 2  2011 Male    Mortality Acute lymphoblastic leukaemia 20-24     3\n 3  2002 Persons Incidence Acute lymphoblastic leukaemia 65-69    11\n 4  1973 Male    Mortality Acute myeloid leukaemia       75-79    12\n 5  2010 Male    Mortality Acute myeloid leukaemia       85+      50\n 6  1984 Female  Incidence Acute myeloid leukaemia       5-9       1\n 7  2003 Male    Incidence Anal cancer                   85+       9\n 8  2011 Male    Mortality Anal cancer                   65-69     1\n 9  1987 Male    Mortality Anal cancer                   10-14     0\n10  1993 Male    Incidence Bladder cancer                40-44    22\n# ℹ 95 more rows\n\n\n\nTry out the following examples by yourself first.\n\nFind the total number of male deaths in each year.\n\nTo find the total number of male deaths in each year, we begin by filtering out the rows where the Sex column contains “Male” and the type column conatins “Mortality”, as we are only interested in male deaths.\n\ncancer_mort |&gt; filter(Sex == \"Male\" & Type == \"Mortality\")\n\nSince we need to compute the total number of deaths in each year, we group this filtered data frame by year. This will create a grouping for each year. This grouping allows us to compute the total number of deaths (i.e., Counts) for each year.\n\ncancer_mort |&gt; \n  filter(Sex == \"Male\" & Type == \"Mortality\") |&gt; \n  group_by(Year)\n\nPutting these operations/functions together, we obtain the final answer:\n\n  Check the Answer\n\ncancer_mort |&gt; \n  filter(Sex == \"Male\" & Type == \"Mortality\") |&gt; \n  group_by(Year) |&gt; \n  summarise(tot_male_deaths = sum(Count))\n\n\n\nFind the top three cancer types and the age group with the highest average cancer incidences reported across all years.\n\nHints:\n\nSince we are concerned only about cancer incidences, first filter the dataset using filter() function to include only the rows with cancer incidences.\nNext, compute the average of cancer incidences reported across all years. If we use summarise() function next, we will have a single average value for the whole data frame. However, this question asks us to find the top three cancer types and age group, which means we need to compute the average after grouping the rows based on cancer type and age group. This can be achieved using the group_by() function with multiple columns as arguments (e.g., group_by(col1, col2)).\nOnce grouped, use summarise() function to compute the mean across these groupings.\nSince we’re interested in only the top three highest values, chain the result of the above functions to the arrange() function to sort the averages in descending order.\n\n\n  Check the Answer\n\ncancer_mort |&gt; \n  filter(Type == \"Incidence\") |&gt; \n  group_by(Cancer_Type, Age) |&gt; \n  summarise(average = mean(Count)) |&gt; \n  arrange(desc(average))\n\n\n\nFind the year, cancer type and age group with the highest cancer count observed among age groups above 29.\n\nHints:\n\nStart by selecting the columns of interest using the select() function. Remember you need to include four columns.\nNext, filter the rows to include only those with age groups above 29. We can use the %in% operator with a vector of age groups to filter rows using the filter() function. For example: filter(Age %in% c(\"30-34\", \"35-39\", \"40-44\", \"45-49\", ..., \"85+\"). This is time consuming and laborious as we need to type 10+ age groups. There are two ways to make this step easier:\n\nUsing the unique() function: This function returns a vector/data frame with duplicate elements removed. In other words, it returns the unique elements. Find the unique elements of the age column (i.e., unique(cancer_mort$Age)) and then create a char vector manually by copying and pasting the age groups of interest.\nUsing ! operator: The easiest way is to select all the age groups that is less than or equal to 29 and then use the ! (NOT) operator to negate the logical vector. For example: filter(!Age %in% c('0-4', '5-9', '10-14','15-19', '20-24', '25-29')) This will select the rows that does not contain age groups in the given vector.\n\nFinnaly, sort the resulting data frame to find the highest cancer count.\n\n\n  Check the Answer\n\ncancer_mort |&gt; \n  filter(!Age %in% c('0-4', '5-9', '10-14','15-19', '20-24', '25-29')) |&gt; \n  arrange(desc(Count))\n\n\n\nFind the minimum, maximum, number of observations and quartile statistics for each cancer type among women, men and other genders.\n\n\n  Check the Answer\n\ncancer_mort |&gt; \n  group_by(Cancer_Type, Sex) |&gt; \n  summarise(minimum_count = min(Count), \n            quartile_1 = quantile(Count, probs = 0.25), \n            quartile_2 = median(Count),\n            quartile_3 = quantile(Count, probs = 0.75),\n            maximum_count = max(Count),\n            n_count = n())\n\n\n\nFind the percentage of deaths attributed to each type of cancer as a function of the total number of deaths.\n\n\n  Check the Answer\n\ncancer_mort |&gt; \n  filter(Type == \"Incidence\") |&gt; \n  group_by(Cancer_Type) |&gt;\n  summarise(tot_deaths = sum(Count)) |&gt; \n  ungroup() |&gt; \n  mutate(percent_deaths = (tot_deaths * 100)/sum(tot_deaths)) \n\n# A tibble: 34 × 3\n   Cancer_Type                   tot_deaths percent_deaths\n   &lt;chr&gt;                              &lt;dbl&gt;          &lt;dbl&gt;\n 1 Acute lymphoblastic leukaemia      15858         0.333 \n 2 Acute myeloid leukaemia            38964         0.817 \n 3 Anal cancer                         3124         0.0655\n 4 Bladder cancer                    125949         2.64  \n 5 Bowel cancer                      628013        13.2   \n 6 Brain cancer                       70161         1.47  \n 7 Breast cancer                     566083        11.9   \n 8 Cervical cancer                    26235         0.550 \n 9 Chronic lymphocytic leukaemia      45438         0.953 \n10 Chronic myeloid leukaemia          15706         0.329 \n# ℹ 24 more rows\n\n\n\n\n\n\nAdditional dplyr functions\nIn this section, we’ll explore several additional functions from the dplyr package. We’ll demonstrate these functions using both the cms_data and cancer_mort datasets.\n\nacross() function\n\nThis function allows you to apply a transformation or calculation across multiple columns of a data frame. It is often used with functions like mutate() or summarise(), enabling you to perform the same operation on multiple columns at once.\n\n# find the mean and standard deviation of star rating and overall rating for each hospital type. \ncms_data |&gt; \n  group_by(hospital_type) |&gt;          \n  summarise(across(                   \n    c(star_rating, overall_rating), \n    list(mean = mean, sd = sd)))\n\n\ndistinct function\n\nThis function is used to select unique rows from a data frame, removing any duplicate rows.\n\n# find the unique or distinct cancer types\ncancer_mort |&gt; distinct(Cancer_Type)\n\n\nslice() function\n\nThis function extracts specific rows from a data frame based on their position. You can specify the row numbers or a range of row numbers to extract.\n\n# select a range of rows\ncancer_mort |&gt; slice(2:5)\n\n# drop rows with negative indices\ncancer_mort |&gt; slice(-(10:n()))\n\n\nslice_head()/slice_tail() functions\n\nThe slice_head() function extracts the first few rows (specified by a number) and the slice_tail() function extracts the last few rows (specified by a number) from a data frame.\n\n# similar to head(3)\ncancer_mort |&gt; slice_head(n = 3)\n\n# similar to tail(4)\ncancer_mort |&gt; slice_tail(n = 4)\n\n\nslice_min()/slice_max() function\n\nThe slice_min() function extracts the rows with the minimum values of a specified variable and the slice_max() function extracts the rows with the maximum values of a specified variable from a data frame.\n\n# 5 rows with the minimum overall rating\ncms_data |&gt; slice_min(overall_rating, n = 5)\n\n# 4 rows with the maximum 5 overall rating\ncms_data |&gt; slice_max(overall_rating, n = 6)\n\n\nslice_sample() function\n\nThis function randomly samples a specified number of rows from a data frame.\n\n# randomly select 5 rows\ncancer_mort |&gt; slice_sample(n = 5)\n\n# randomly select 3 rows from each groupings\ncancer_mort |&gt; group_by(Age) |&gt; slice_sample(n = 3)\n\n\nadd_row() function\n\nThis function adds one or more rows to a data frame. You can specify the values for each column of the new rows.\n\n# add a row before the 3rd row. Missing values are entered as NA\ncancer_mort |&gt; add_row(Year = 2024, Type = \"Mortality\", Count = 100, .before = 3)\n\n\nrelocate() function\n\nThis function allows you to change the position of columns within a data frame. You can specify the target position where you want to move the column to.\n\n# move the Cancer type column to be positioned after the Year column\ncancer_mort |&gt; relocate(Cancer_Type, .after = Year)"
  },
  {
    "objectID": "vignettes/3_Data_Manipulation.html#joining-data-frames",
    "href": "vignettes/3_Data_Manipulation.html#joining-data-frames",
    "title": "Step 3: Transforming Data",
    "section": "Joining Data Frames",
    "text": "Joining Data Frames\nOften, data originates from various sources or files, and the need arises to consolidate them for analysis. These datasets, when merged, are often referred to as relational data due to the inherent relationships between them that we aim to leverage. Within the tidyverse framework, this process of merging related data is termed joining. Here, we combine data from multiple datasets based on a common variable or set of variables.\n\nFor illustration purposes, let’s use the following two data frames in the subsequent examples.\n\nleft = data.frame(\n         key1 = c(\"K0\", \"K1\", \"K2\", \"K3\"),\n         A    = c(\"A0\", \"A1\", \"A2\", \"A3\"),\n         B    = c(\"B0\", \"B1\", \"B2\", \"B3\"))\n\nright = data.frame(\n         key1 = c(\"K0\", \"K1\", \"K1\", \"K4\"),\n         C    = c(\"C0\", \"C1\", \"C2\", \"C3\"),\n         D    = c(\"D0\", \"D1\", \"D2\", \"D3\"))\n\nThere are several types of joins commonly used in R outlined below.\n\nLeft Join\nA left join returns all rows from the left data frame (the first data frame specified) and matching rows from the right data frame (the second data frame specified). Non-matching rows in the right data frame have NULL (or NA) values in the result.\n\n\n\n\nleft\n\n  key1  A  B\n1   K0 A0 B0\n2   K1 A1 B1\n3   K2 A2 B2\n4   K3 A3 B3\n\n\n\n\n\n\nright\n\n  key1  C  D\n1   K0 C0 D0\n2   K1 C1 D1\n3   K1 C2 D2\n4   K4 C3 D3\n\n\n\n\n\nleft_join(left, right, by = \"key1\")\n\n  key1  A  B    C    D\n1   K0 A0 B0   C0   D0\n2   K1 A1 B1   C1   D1\n3   K1 A1 B1   C2   D2\n4   K2 A2 B2 &lt;NA&gt; &lt;NA&gt;\n5   K3 A3 B3 &lt;NA&gt; &lt;NA&gt;\n\n\n\n\nRight join\nA right join is similar to a left join but returns all rows from the right data frame and matching rows from the left data frame. Non-matching rows in the left data frame have NULL (or NA) values in the result.\n\n\n\n\nleft\n\n  key1  A  B\n1   K0 A0 B0\n2   K1 A1 B1\n3   K2 A2 B2\n4   K3 A3 B3\n\n\n\n\n\n\nright\n\n  key1  C  D\n1   K0 C0 D0\n2   K1 C1 D1\n3   K1 C2 D2\n4   K4 C3 D3\n\n\n\n\n\nright_join(left, right, by = \"key1\")\n\n  key1    A    B  C  D\n1   K0   A0   B0 C0 D0\n2   K1   A1   B1 C1 D1\n3   K1   A1   B1 C2 D2\n4   K4 &lt;NA&gt; &lt;NA&gt; C3 D3\n\n\n\n\nInner join\nAn inner join returns only the rows with matching values in the specified columns (the common key). It combines data from two or more tables or DataFrames based on the intersection of keys, excluding rows that do not have corresponding matches in both tables.\n\n\n\n\nleft\n\n  key1  A  B\n1   K0 A0 B0\n2   K1 A1 B1\n3   K2 A2 B2\n4   K3 A3 B3\n\n\n\n\n\n\nright\n\n  key1  C  D\n1   K0 C0 D0\n2   K1 C1 D1\n3   K1 C2 D2\n4   K4 C3 D3\n\n\n\n\n\ninner_join(left, right, by = \"key1\")\n\n  key1  A  B  C  D\n1   K0 A0 B0 C0 D0\n2   K1 A1 B1 C1 D1\n3   K1 A1 B1 C2 D2\n\n\n\n\nFull Join\nA full join returns all rows from both datasets, filling in NA values for non-matching rows.\n\n\n\n\nleft\n\n  key1  A  B\n1   K0 A0 B0\n2   K1 A1 B1\n3   K2 A2 B2\n4   K3 A3 B3\n\n\n\n\n\n\nright\n\n  key1  C  D\n1   K0 C0 D0\n2   K1 C1 D1\n3   K1 C2 D2\n4   K4 C3 D3\n\n\n\n\n\nfull_join(left, right, by = \"key1\")\n\n  key1    A    B    C    D\n1   K0   A0   B0   C0   D0\n2   K1   A1   B1   C1   D1\n3   K1   A1   B1   C2   D2\n4   K2   A2   B2 &lt;NA&gt; &lt;NA&gt;\n5   K3   A3   B3 &lt;NA&gt; &lt;NA&gt;\n6   K4 &lt;NA&gt; &lt;NA&gt;   C3   D3"
  },
  {
    "objectID": "vignettes/3_Data_Manipulation.html#binding-multiple-data-frames",
    "href": "vignettes/3_Data_Manipulation.html#binding-multiple-data-frames",
    "title": "Step 3: Transforming Data",
    "section": "Binding multiple data frames",
    "text": "Binding multiple data frames\nThe dplyr package provides convenient functions forbinding data frames by row or column to combine one or more data frames into one data frame.\nFor illustration purposes, let’s use the following data frames in the subsequent examples.\n\ndf1 = data.frame(\n  ID         = 1:3,\n  name       = c(\"Eva\", \"Charlie\", \"John\"),\n  occupation = c(\"Doctor\", \"Nurse\", \"Manager\"))\ndf2 = data.frame(\n  ID         = 4:6,\n  name       = c(\"Peter\", \"Jane\", \"Alice\"),\n  occupation = c(\"Radiographer\", \"Therapist\", \"Consultant\"))\ndf3 = data.frame(\n  location   = c(\"Parkville\", \"Box Hill\", \"East Melbourne\"),\n  grade      = c(\"A\", \"A\", \"C\"))\n\n\nBinding by Row:\n\nTo bind data frames by row, you can use the bind_rows() function.\nThis function stacks data frames on top of each other, matching columns by name.\n\n\n\n\n\ndf1\n\n  ID    name occupation\n1  1     Eva     Doctor\n2  2 Charlie      Nurse\n3  3    John    Manager\n\n\n\n\n\n\ndf2\n\n  ID  name   occupation\n1  4 Peter Radiographer\n2  5  Jane    Therapist\n3  6 Alice   Consultant\n\n\n\n\n\nbind_rows(df1, df2)\n\n  ID    name   occupation\n1  1     Eva       Doctor\n2  2 Charlie        Nurse\n3  3    John      Manager\n4  4   Peter Radiographer\n5  5    Jane    Therapist\n6  6   Alice   Consultant\n\n\n\nBinding by Column:\n\nTo bind data frames by column, you can use the bind_cols() function from dplyr.\nThis function appends columns from one data frame to another, matching rows by position.\n\n\n\n\n\ndf1\n\n  ID    name occupation\n1  1     Eva     Doctor\n2  2 Charlie      Nurse\n3  3    John    Manager\n\n\n\n\n\n\ndf3\n\n        location grade\n1      Parkville     A\n2       Box Hill     A\n3 East Melbourne     C\n\n\n\n\n\nbind_cols(df1, df3)\n\n  ID    name occupation       location grade\n1  1     Eva     Doctor      Parkville     A\n2  2 Charlie      Nurse       Box Hill     A\n3  3    John    Manager East Melbourne     C\n\n\nThat wraps up our exploration of data transformation using the dplyr package. In the next section, we’ll delve into visualization with the ggplot2 package from the tidyverse suite. We’ll apply the functions we’ve learned in this section to generate various plots. Stay tuned for more!"
  },
  {
    "objectID": "vignettes/2_Reading_tidying_data.html",
    "href": "vignettes/2_Reading_tidying_data.html",
    "title": "Into the Tidyverse",
    "section": "",
    "text": "Common tasks in working with data include actions like removing rows or columns, performing calculations, or adding new columns. This sort of operations is known as data manipulation. It is the process of cleaning, organizing, and transforming raw data into a more structured and usable format for analysis.\nIn this workshop, we’ll guide you through the process of data manipulation in R, starting with the tidyverse. The tidyverse is a collection of packages that align with a data science philosophy developed by Hadley Wickham and the RStudio team. Many users find it to be a more intuitive way to grasp R concepts. Although some tasks may be more straightforward in base-R, we’ll also highlight those aspects.\nIf you’ve already installed the tidyverse package (if not, you can do so by running the command: install.packages(\"tidyverse\")), let’s proceed to load it into our R session:\nlibrary(tidyverse)\nThe following are key techniques outlined in Hadley Wickham and Garrett Grolemund’s book, R for Data Science:\nThis workshop focuses on:\nThis workflow is of utmost importance. Instead of constructing analyses based on the unconventional format of your data, take measures to tidy up your data. Tidy data enables the use of number of analytical and visualization tools. It eliminates the need to develop ad-hoc methods to accommodate your data. This not only saves time but also enhances the clarity and comprehensibility of your work, benefiting both your collaborators and, most importantly, your future self."
  },
  {
    "objectID": "vignettes/2_Reading_tidying_data.html#preloaded-data-in-r-packages",
    "href": "vignettes/2_Reading_tidying_data.html#preloaded-data-in-r-packages",
    "title": "Into the Tidyverse",
    "section": "Preloaded Data in R Packages",
    "text": "Preloaded Data in R Packages\nA great way to learn data science tools is using the data provided by R packages. The data() function is a convenient way to explore and import pre-loaded datasets that come bundled with the R environment.\n\nlibrary(tidyverse)\ndata()\n\n\nView Output\n\n\n\n\n\n\nTo import pre-loaded datasets bundled with a particular package (e.g., tidyr):\n\ndata(package = \"tidyr\")\n\n\nView Output\n\n\n\n\n\n\nWhen you load a package the pre-loaded datasets automatically imported into you R environment. Therefore you can access them directly as follows.\n\nhousehold\n\n\nOutput\n\n\n# A tibble: 5 × 5\n  family dob_child1 dob_child2 name_child1 name_child2\n   &lt;int&gt; &lt;date&gt;     &lt;date&gt;     &lt;chr&gt;       &lt;chr&gt;      \n1      1 1998-11-26 2000-01-29 Susan       Jose       \n2      2 1996-06-22 NA         Mark        &lt;NA&gt;       \n3      3 2002-07-11 2004-04-05 Sam         Seth       \n4      4 2004-10-10 2009-08-27 Craig       Khai       \n5      5 2000-12-05 2005-02-28 Parker      Gracie     \n\n\n\n\n?household\n\n\nView Output\n\n&lt;!DOCTYPE html&gt;\n\n\n\nR: Household data\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhousehold\n\n\nR Documentation\n\n\n\n\n\nHousehold data\n\n\nDescription\n\n\nThis dataset is based on an example in vignette(“datatable-reshape”, package = “data.table”)\n\n\nUsage\n\nhousehold\n\n\nFormat\n\n\nA data frame with 5 rows and 5 columns:\n\n\n\nfamily\n\n\n\nFamily identifier\n\n\n\ndob_child1\n\n\n\nDate of birth of first child\n\n\n\ndob_child2\n\n\n\nDate of birth of second child\n\n\n\nname_child1\n\n\n\nName of first child\n\n\n\n\n?\n\n\n\nname_child2\n\n\n\nName of second child"
  },
  {
    "objectID": "vignettes/2_Reading_tidying_data.html#reading-the-data",
    "href": "vignettes/2_Reading_tidying_data.html#reading-the-data",
    "title": "Into the Tidyverse",
    "section": "Reading the Data",
    "text": "Reading the Data\nAt some point, you want to apply what you’ve learned to your own data. In this section, you’ll learn the basics of reading data files into R using the readr package. The goal of readr is to provide a fast and friendly way to read rectangular data from delimited files, such as comma-separated values (CSV) and tab-separated values (TSV). It is designed to parse many types of data.\nWe will use the read_csv() function from readr package to import a dataset. (See also read.csv() in base R.) CSV short for Comma Separated Values, is a text format commonly used to store tabular data. Conventionally the first line contains column headings.\nThe first argument of the read_csv() function takes the path to the file (or a web link). The following code will work if the cms_hospital_patient_satisfaction_2016_sampled.csv file is in the data/patient_satisfaction path.\n\n# here the first argument is a path\ncms_data &lt;- read_csv(\"data/patient_satisfaction/cms_hospital_patient_satisfaction_2016_sampled.csv\")\n\n\nOutput\n\n\nRows: 15 Columns: 8\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (4): ID, Facility Name, County, Hospital Type\ndbl (4): Star Rating, No of Surveys, Response Rate, Overall Rating\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\n\n# here the first argument is a web link\nmtvcars &lt;- read_csv(\"https://github.com/tidyverse/readr/raw/main/inst/extdata/mtcars.csv\")\n\n\nOutput\n\n\nRows: 32 Columns: 11\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (11): mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\nThis command prints out a message telling you the number of rows and columns of data, the delimiter that was used, and the column specifications (names of columns organized by the type of data the column contains)."
  },
  {
    "objectID": "vignettes/2_Reading_tidying_data.html#other-file-types",
    "href": "vignettes/2_Reading_tidying_data.html#other-file-types",
    "title": "Into the Tidyverse",
    "section": "Other file types",
    "text": "Other file types\nOnce you’ve mastered read_csv(), using other functions in the readr package is straightforward. It’s just a matter of knowing which function to use:\n\nread_csv2() reads semicolon-separated files. These use ; instead of , to separate fields and are common in countries that use , as the decimal marker or thousands seperator.\nread_tsv()reads tab-delimited files.\nread_delim() reads in files with any delimiter, attempting to automatically guess the delimiter if you don’t specify it."
  },
  {
    "objectID": "vignettes/2_Reading_tidying_data.html#exploring-the-data",
    "href": "vignettes/2_Reading_tidying_data.html#exploring-the-data",
    "title": "Into the Tidyverse",
    "section": "Exploring the Data",
    "text": "Exploring the Data\nIn the previous section we imported a dataset that is bundled with the tidyr package, into a dataframe named household. In the next section we read in a CSV file and created a data frame named cms_data. This section demonstrates different ways to get to know these two data objects.\nThe class() function is used to identify the data type or data structure of an object (or variable):\n\nclass(household)\nclass(cms_data)\n\n\nOutput\n\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\n[1] \"spec_tbl_df\" \"tbl_df\"      \"tbl\"         \"data.frame\" \n\n\n\nWhen the name of the object (data frame) is typed, the first few lines along with some information, such as the number of rows are displayed:\n\ncms_data\n\n\nOutput\n\n\n# A tibble: 15 × 8\n   ID     `Facility Name`   County `Hospital Type` `Star Rating` `No of Surveys`\n   &lt;chr&gt;  &lt;chr&gt;             &lt;chr&gt;  &lt;chr&gt;                   &lt;dbl&gt;           &lt;dbl&gt;\n 1 050424 SCRIPPS GREEN HO… SAN D… Acute Care Hos…             4            3110\n 2 140103 ST BERNARD HOSPI… COOK   Acute Care Hos…             1             264\n 3 100051 SOUTH LAKE HOSPI… LAKE   Acute Care Hos…             2            1382\n 4 040062 MERCY HOSPITAL F… SEBAS… Acute Care Hos…             3            2506\n 5 440048 BAPTIST MEMORIAL… SHELBY Acute Care Hos…             2            1799\n 6 450011 ST JOSEPH REGION… BRAZOS Acute Care Hos…             3            1379\n 7 151317 GREENE COUNTY GE… GREENE Critical Acces…             3             114\n 8 061327 SOUTHWEST MEMORI… MONTE… Critical Acces…             4             247\n 9 490057 SENTARA GENERAL … VIRGI… Acute Care Hos…             4             619\n10 110215 PIEDMONT FAYETTE… FAYET… Acute Care Hos…             2            1714\n11 050704 MISSION COMMUNIT… LOS A… Acute Care Hos…             3             241\n12 100296 DOCTORS HOSPITAL  MIAMI… Acute Care Hos…             4             393\n13 440003 SUMNER REGIONAL … SUMNER Acute Care Hos…             4             680\n14 501339 WHIDBEY GENERAL … ISLAND Critical Acces…             3             389\n15 050116 NORTHRIDGE MEDIC… LOS A… Acute Care Hos…             3            1110\n# ℹ 2 more variables: `Response Rate` &lt;dbl&gt;, `Overall Rating` &lt;dbl&gt;\n\n\n\nThe dim() function prints the dimensions (rows x columns) of the data frame:\n\ndim(cms_data)\n\n\nOutput\n\n\n[1] 15  8\n\n\n\nThis information is available at the environment pane in the top right panel as the number of observations (rows) and variables (columns).\nThe nrow() function prints the number of rows while ncol() prints the number of columns:\n\nnrow(cms_data)\nncol(cms_data)\n\n\nOutput\n\n\n[1] 15\n\n\n[1] 8\n\n\n\nThe View() function gives a spreadsheet-like view of the data frame:\n\nView(cms_data)\n\nBy clicking the object on the environment tab also gives a spreadsheet-like view of the object: \nThe glimpse()function (dplyr package) displays a compact summary of the data frame, showing you key details such as the data types of each column, the first few values, and the total number of observations.\n\nglimpse(cms_data)\n\n\nOutput\n\n\nRows: 15\nColumns: 8\n$ ID               &lt;chr&gt; \"050424\", \"140103\", \"100051\", \"040062\", \"440048\", \"45…\n$ `Facility Name`  &lt;chr&gt; \"SCRIPPS GREEN HOSPITAL\", \"ST BERNARD HOSPITAL\", \"SOU…\n$ County           &lt;chr&gt; \"SAN DIEGO\", \"COOK\", \"LAKE\", \"SEBASTIAN\", \"SHELBY\", \"…\n$ `Hospital Type`  &lt;chr&gt; \"Acute Care Hospital\", \"Acute Care Hospital\", \"Acute …\n$ `Star Rating`    &lt;dbl&gt; 4, 1, 2, 3, 2, 3, 3, 4, 4, 2, 3, 4, 4, 3, 3\n$ `No of Surveys`  &lt;dbl&gt; 3110, 264, 1382, 2506, 1799, 1379, 114, 247, 619, 171…\n$ `Response Rate`  &lt;dbl&gt; 41, 6, 20, 35, 18, 24, 22, 34, 32, 21, 14, 24, 35, 29…\n$ `Overall Rating` &lt;dbl&gt; 5, 2, 2, 3, 2, 3, 3, 3, 3, 2, 3, 3, 2, 3, 2\n\n\n\nThe head() function prints the top 6 rows of a data frame:\n\nhead(cms_data)\n\n\nOutput\n\n\n# A tibble: 6 × 8\n  ID     `Facility Name`    County `Hospital Type` `Star Rating` `No of Surveys`\n  &lt;chr&gt;  &lt;chr&gt;              &lt;chr&gt;  &lt;chr&gt;                   &lt;dbl&gt;           &lt;dbl&gt;\n1 050424 SCRIPPS GREEN HOS… SAN D… Acute Care Hos…             4            3110\n2 140103 ST BERNARD HOSPIT… COOK   Acute Care Hos…             1             264\n3 100051 SOUTH LAKE HOSPIT… LAKE   Acute Care Hos…             2            1382\n4 040062 MERCY HOSPITAL FO… SEBAS… Acute Care Hos…             3            2506\n5 440048 BAPTIST MEMORIAL … SHELBY Acute Care Hos…             2            1799\n6 450011 ST JOSEPH REGIONA… BRAZOS Acute Care Hos…             3            1379\n# ℹ 2 more variables: `Response Rate` &lt;dbl&gt;, `Overall Rating` &lt;dbl&gt;\n\n\n\nSimilarly, the tail() function prints the bottom 6 rows of the data frame:\n\ntail(cms_data)\n\n\nOutput\n\n\n# A tibble: 6 × 8\n  ID     `Facility Name`    County `Hospital Type` `Star Rating` `No of Surveys`\n  &lt;chr&gt;  &lt;chr&gt;              &lt;chr&gt;  &lt;chr&gt;                   &lt;dbl&gt;           &lt;dbl&gt;\n1 110215 PIEDMONT FAYETTE … FAYET… Acute Care Hos…             2            1714\n2 050704 MISSION COMMUNITY… LOS A… Acute Care Hos…             3             241\n3 100296 DOCTORS HOSPITAL   MIAMI… Acute Care Hos…             4             393\n4 440003 SUMNER REGIONAL M… SUMNER Acute Care Hos…             4             680\n5 501339 WHIDBEY GENERAL H… ISLAND Critical Acces…             3             389\n6 050116 NORTHRIDGE MEDICA… LOS A… Acute Care Hos…             3            1110\n# ℹ 2 more variables: `Response Rate` &lt;dbl&gt;, `Overall Rating` &lt;dbl&gt;\n\n\n\nThe colnames() function displays all the column names:\n\ncolnames(cms_data)\n\n[1] \"ID\"             \"Facility Name\"  \"County\"         \"Hospital Type\" \n[5] \"Star Rating\"    \"No of Surveys\"  \"Response Rate\"  \"Overall Rating\"\n\n\nThe $ symbol allows access to individual columns. To display ‘Hospital Type’ column:\n\ncms_data$Hospital Type\n\nError: &lt;text&gt;:1:19: unexpected symbol\n1: cms_data$Hospital Type\n                      ^\n\n\nSince the column names contain spaces, they need to be enclosed within `` (backticks) for R to interpret it as a single variable:\n\ncms_data$`Hospital Type` # or cms_data$\"Hospital Type\"\n\nIt is a good practice to rename all the columns with spaces into a format that R can interpret. Conventionally, _ (underscore) is used to separate words in column names and variables instead of (space). We can rename a single column using the rename() function:\n\ncms_data &lt;- rename(cms_data, Hospital_Type = \"Hospital Type\")\nhead(cms_data)\n\n\nOutput\n\n\n# A tibble: 6 × 8\n  ID     `Facility Name`      County Hospital_Type `Star Rating` `No of Surveys`\n  &lt;chr&gt;  &lt;chr&gt;                &lt;chr&gt;  &lt;chr&gt;                 &lt;dbl&gt;           &lt;dbl&gt;\n1 050424 SCRIPPS GREEN HOSPI… SAN D… Acute Care H…             4            3110\n2 140103 ST BERNARD HOSPITAL  COOK   Acute Care H…             1             264\n3 100051 SOUTH LAKE HOSPITAL  LAKE   Acute Care H…             2            1382\n4 040062 MERCY HOSPITAL FORT… SEBAS… Acute Care H…             3            2506\n5 440048 BAPTIST MEMORIAL HO… SHELBY Acute Care H…             2            1799\n6 450011 ST JOSEPH REGIONAL … BRAZOS Acute Care H…             3            1379\n# ℹ 2 more variables: `Response Rate` &lt;dbl&gt;, `Overall Rating` &lt;dbl&gt;\n\n\n\nNote: To modify the original cms_data object, it is essential to assign the renamed object to cms_data. Otherwise, a copy of the cms_data object is changed.\nOr by directly assigning a new column name:\n\ncolnames(cms_data)[2] &lt;- \"Facility_Name\"\nhead(cms_data)\n\n\nOutput\n\n\n# A tibble: 6 × 8\n  ID     Facility_Name        County Hospital_Type `Star Rating` `No of Surveys`\n  &lt;chr&gt;  &lt;chr&gt;                &lt;chr&gt;  &lt;chr&gt;                 &lt;dbl&gt;           &lt;dbl&gt;\n1 050424 SCRIPPS GREEN HOSPI… SAN D… Acute Care H…             4            3110\n2 140103 ST BERNARD HOSPITAL  COOK   Acute Care H…             1             264\n3 100051 SOUTH LAKE HOSPITAL  LAKE   Acute Care H…             2            1382\n4 040062 MERCY HOSPITAL FORT… SEBAS… Acute Care H…             3            2506\n5 440048 BAPTIST MEMORIAL HO… SHELBY Acute Care H…             2            1799\n6 450011 ST JOSEPH REGIONAL … BRAZOS Acute Care H…             3            1379\n# ℹ 2 more variables: `Response Rate` &lt;dbl&gt;, `Overall Rating` &lt;dbl&gt;\n\n\n\nUsing the above methods to rename multiple columns just to replace space with underscore can be laborious. A quick way to replace all spaces in the column names with underscore is shown below.\nOption 1:\n\n# by string substituting _ in place of ' '(space)\ncolnames(cms_data) &lt;- gsub(\" \", \"_\", colnames(cms_data))\ncolnames(cms_data)\n\n\nOutput\n\n\n[1] \"ID\"             \"Facility_Name\"  \"County\"         \"Hospital_Type\" \n[5] \"Star_Rating\"    \"No_of_Surveys\"  \"Response_Rate\"  \"Overall_Rating\"\n\n\n\nHere the gsub() function replace space with underscores in the column names of the cms_data. This new object needs to be assigned (&lt;-) to colnames(cms_data) in order for the changes to be saved in the cms_data object.\nOption 2:\nHere we use the janitor package which contains functions to clean data. You first need to install and load the library before using it.\n\n# using janitor package\nlibrary(janitor) # remember to install janitor: install.packages(\"janitor\")\ncms_data &lt;- cms_data |&gt; clean_names()\ncms_data\n\n\n\n\n\nOutput\n\n\n# A tibble: 15 × 8\n   id     facility_name           county hospital_type star_rating no_of_surveys\n   &lt;chr&gt;  &lt;chr&gt;                   &lt;chr&gt;  &lt;chr&gt;               &lt;dbl&gt;         &lt;dbl&gt;\n 1 050424 SCRIPPS GREEN HOSPITAL  SAN D… Acute Care H…           4          3110\n 2 140103 ST BERNARD HOSPITAL     COOK   Acute Care H…           1           264\n 3 100051 SOUTH LAKE HOSPITAL     LAKE   Acute Care H…           2          1382\n 4 040062 MERCY HOSPITAL FORT SM… SEBAS… Acute Care H…           3          2506\n 5 440048 BAPTIST MEMORIAL HOSPI… SHELBY Acute Care H…           2          1799\n 6 450011 ST JOSEPH REGIONAL HEA… BRAZOS Acute Care H…           3          1379\n 7 151317 GREENE COUNTY GENERAL … GREENE Critical Acc…           3           114\n 8 061327 SOUTHWEST MEMORIAL HOS… MONTE… Critical Acc…           4           247\n 9 490057 SENTARA GENERAL HOSPIT… VIRGI… Acute Care H…           4           619\n10 110215 PIEDMONT FAYETTE HOSPI… FAYET… Acute Care H…           2          1714\n11 050704 MISSION COMMUNITY HOSP… LOS A… Acute Care H…           3           241\n12 100296 DOCTORS HOSPITAL        MIAMI… Acute Care H…           4           393\n13 440003 SUMNER REGIONAL MEDICA… SUMNER Acute Care H…           4           680\n14 501339 WHIDBEY GENERAL HOSPIT… ISLAND Critical Acc…           3           389\n15 050116 NORTHRIDGE MEDICAL CEN… LOS A… Acute Care H…           3          1110\n# ℹ 2 more variables: response_rate &lt;dbl&gt;, overall_rating &lt;dbl&gt;\n\n\n\nHere we are sending the cms_data data frame into the function clean_names() which replaces replaces spaces with underscore in column names. Note that it also convert all characters in column names to lower case.\nThe default format is snake case styled as snake_case. You can specify other formats like camel case, title case.\nOption 3:\nAdditionally, we can use the make.names() function in base R which replaces ’ ’ (spaces) with . (dots).\n\n# using make.names() function\ncolnames(cms_data) &lt;-  make.names(colnames(cms_data))\ncolnames(cms_data) \n\n\nOutput\n\n\n[1] \"ID\"             \"Facility_Name\"  \"County\"         \"Hospital_Type\" \n[5] \"Star.Rating\"    \"No.of.Surveys\"  \"Response.Rate\"  \"Overall.Rating\"\n\n\n\nThe str() function shows the structure of the data:\n\nstr(cms_data)\n\n\nOutput\n\n\nspc_tbl_ [15 × 8] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ ID            : chr [1:15] \"050424\" \"140103\" \"100051\" \"040062\" ...\n $ Facility_Name : chr [1:15] \"SCRIPPS GREEN HOSPITAL\" \"ST BERNARD HOSPITAL\" \"SOUTH LAKE HOSPITAL\" \"MERCY HOSPITAL FORT SMITH\" ...\n $ County        : chr [1:15] \"SAN DIEGO\" \"COOK\" \"LAKE\" \"SEBASTIAN\" ...\n $ Hospital_Type : chr [1:15] \"Acute Care Hospital\" \"Acute Care Hospital\" \"Acute Care Hospital\" \"Acute Care Hospital\" ...\n $ Star Rating   : num [1:15] 4 1 2 3 2 3 3 4 4 2 ...\n $ No of Surveys : num [1:15] 3110 264 1382 2506 1799 ...\n $ Response Rate : num [1:15] 41 6 20 35 18 24 22 34 32 21 ...\n $ Overall Rating: num [1:15] 5 2 2 3 2 3 3 3 3 2 ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   ID = col_character(),\n  ..   `Facility Name` = col_character(),\n  ..   County = col_character(),\n  ..   `Hospital Type` = col_character(),\n  ..   `Star Rating` = col_double(),\n  ..   `No of Surveys` = col_double(),\n  ..   `Response Rate` = col_double(),\n  ..   `Overall Rating` = col_double()\n  .. )\n - attr(*, \"problems\")=&lt;externalptr&gt; \n\n\n\nThe summary() function generates summary statistics:\n\nsummary(cms_data)\n\n\nOutput\n\n\n      ID            Facility_Name         County          Hospital_Type     \n Length:15          Length:15          Length:15          Length:15         \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n  Star Rating  No of Surveys    Response Rate Overall Rating \n Min.   :1.0   Min.   : 114.0   Min.   : 6    Min.   :2.000  \n 1st Qu.:2.5   1st Qu.: 326.5   1st Qu.:20    1st Qu.:2.000  \n Median :3.0   Median : 680.0   Median :24    Median :3.000  \n Mean   :3.0   Mean   :1063.1   Mean   :25    Mean   :2.733  \n 3rd Qu.:4.0   3rd Qu.:1548.0   3rd Qu.:33    3rd Qu.:3.000  \n Max.   :4.0   Max.   :3110.0   Max.   :41    Max.   :5.000  \n\n\n\nA statitical overview can be obtained using the skim() function in skimr package:\n\nlibrary(skimr)\nskim(cms_data)\n\n\nOutput\n\n\n\nData summary\n\n\nName\ncms_data\n\n\nNumber of rows\n15\n\n\nNumber of columns\n8\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n4\n\n\nnumeric\n4\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\nID\n0\n1\n6\n6\n0\n15\n0\n\n\nFacility_Name\n0\n1\n16\n32\n0\n15\n0\n\n\nCounty\n0\n1\n4\n14\n0\n14\n0\n\n\nHospital_Type\n0\n1\n19\n24\n0\n2\n0\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\nStar Rating\n0\n1\n3.00\n0.93\n1\n2.5\n3\n4\n4\n▁▃▁▇▇\n\n\nNo of Surveys\n0\n1\n1063.13\n909.05\n114\n326.5\n680\n1548\n3110\n▇▁▃▁▁\n\n\nResponse Rate\n0\n1\n25.00\n9.30\n6\n20.0\n24\n33\n41\n▂▇▇▆▆\n\n\nOverall Rating\n0\n1\n2.73\n0.80\n2\n2.0\n3\n3\n5\n▆▇▁▁▁"
  },
  {
    "objectID": "vignettes/2_Reading_tidying_data.html#writing-data-to-a-file",
    "href": "vignettes/2_Reading_tidying_data.html#writing-data-to-a-file",
    "title": "Into the Tidyverse",
    "section": "Writing Data to a File",
    "text": "Writing Data to a File\nWriting data to a file is a fundamental operation in programming and data analysis. It involves taking data from within a program or environment and storing it in a file on a disk for later use or sharing. This section explains the basics of writing a data file using the readr package.\nThe write_csv() and write_tsv() functions are part of the readr package, which is designed for writing delimited files like CSV (comma-separated values) and TSV (tab-separated values). These functions are used to write data frames into CSV and TSV files, respectively.\nWe first provide the variable name of the data frame followed by the file name (ideally including the full folder location).\nTo write a CSV file:\n\n# on Mac:\nwrite_csv(cms_data, \"~/Desktop/cms_data.csv\")\n\n# on Windows\nwrite_csv(cms_data, \"C:/Users/srajapaksa/Desktop/cms_data.csv\")\n\nTo write a TSV file:\n\n# on Mac:\nwrite_tsv(cms_data, \"~/Desktop/cms_data.csv\")\n\n# on Windows\nwrite_tsv(cms_data, \"C:/Users/srajapaksa/Desktop/cms_data.csv\")"
  },
  {
    "objectID": "vignettes/2_Reading_tidying_data.html#converting-data-from-wide-to-long-format",
    "href": "vignettes/2_Reading_tidying_data.html#converting-data-from-wide-to-long-format",
    "title": "Into the Tidyverse",
    "section": "Converting data from wide to long format",
    "text": "Converting data from wide to long format\nFirst read the counts file called GSE60450_normalized_data.csv that is in a folder called data (i.e. the path to the file should be data/GSE60450_normalized_data.csv).\n\ncounts &lt;- read_csv(\"data/GSE60450_normalized_data.csv\")\nhead(counts)\n\n\nOutput\n\n\n# A tibble: 6 × 14\n  X           gene_symbol GSM1480291 GSM1480292 GSM1480293 GSM1480294 GSM1480295\n  &lt;chr&gt;       &lt;chr&gt;            &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n1 ENSMUSG000… Jak3           82.2       81.2          36.1    36.6       12.4   \n2 ENSMUSG000… Usp36          88.2       94.6          76.1    63.7       27.1   \n3 ENSMUSG000… Mir135a-2       0          0             0       0          0     \n4 ENSMUSG000… Strn4          94.3       85.1          59.5    54.3       24.4   \n5 ENSMUSG000… Mir6921         0.0895     0.0840        0       0.0846     0.0388\n6 ENSMUSG000… Rubcn          37.8       37.7          21.3    27.7       30.1   \n# ℹ 7 more variables: GSM1480296 &lt;dbl&gt;, GSM1480297 &lt;dbl&gt;, GSM1480298 &lt;dbl&gt;,\n#   GSM1480299 &lt;dbl&gt;, GSM1480300 &lt;dbl&gt;, GSM1480301 &lt;dbl&gt;, GSM1480302 &lt;dbl&gt;\n\n\n\nTo transform this table from a wide format to a long format, we use the pivot_longer() function. It’s important to note that this function does not create tidy data as it duplicates rows. However, the output in ‘long format’ from pivot_longer() is often necessary for ggplot, where each aesthetic or facet category must be a single column of values and for left_join(), which will be introduced later.\nThis operation will convert multiple columns with counts for each sample into a single column containing all the expression values, as illustrated in the image below.\n The pivot_longer() function takes three arguments:\n\ncols = : a vector indicating the names of the columns to be converted into labels in long form.\nnames_to = : a name or vector of names for the new column(s) containing the labels from the specified columns.\n**values_to =* *: a name for the new column containing the values corresponding to the specified columns.\n\nIt’s important to note that when using pivot_wider(), the new column names need to be enclosed in quotes.\n\nseqdata &lt;- counts |&gt; \n  pivot_longer(cols = starts_with(\"GSM\"), \n               names_to = \"Sample\", \n               values_to = \"Count\")\n\nThe cols = starts_with(\"GSM\") command returns a vector of columns whose names starts with “GSM”. pivot_longer() will then transform the those columns into two new columns, denoted as “Sample” and “Count.” The parameter names_to = \"Sample\" indicates that the new column containing the specified columns (defined by cols) should be named “Sample,” while values_to = \"Count\" specifies that the new column containing the values should be named “Count.”\n\nseqdata\n\n\nOutput\n\n\n# A tibble: 240 × 4\n   X                  gene_symbol Sample     Count\n   &lt;chr&gt;              &lt;chr&gt;       &lt;chr&gt;      &lt;dbl&gt;\n 1 ENSMUSG00000031805 Jak3        GSM1480291 82.2 \n 2 ENSMUSG00000031805 Jak3        GSM1480292 81.2 \n 3 ENSMUSG00000031805 Jak3        GSM1480293 36.1 \n 4 ENSMUSG00000031805 Jak3        GSM1480294 36.6 \n 5 ENSMUSG00000031805 Jak3        GSM1480295 12.4 \n 6 ENSMUSG00000031805 Jak3        GSM1480296 11.9 \n 7 ENSMUSG00000031805 Jak3        GSM1480297 10.6 \n 8 ENSMUSG00000031805 Jak3        GSM1480298 14.9 \n 9 ENSMUSG00000031805 Jak3        GSM1480299  7.57\n10 ENSMUSG00000031805 Jak3        GSM1480300  7.06\n# ℹ 230 more rows\n\n\n\nAlternatively, we could achieve the same outcome by specifying a column range using the following command:\n\nseqdata &lt;- counts |&gt; \n  pivot_longer(cols = GSM1480291:GSM1480302, \n               names_to = \"Sample\", \n               values_to = \"Count\")\n\nWe can also specify the columns we don’t want to reformat, and pivot_longer() will then reformat all the columns except those. To achieve this, we place a minus sign (“-”) in front of the column names that we wish to exclude. This is a commonly used approach with pivot_longer(), as it can be more convenient to exclude columns we don’t need rather than explicitly include the ones we want.\n\nseqdata &lt;- counts |&gt; \n  pivot_longer(cols = -c(X, gene_symbol), \n               names_to = \"Sample\", \n               values_to = \"Count\")"
  },
  {
    "objectID": "vignettes/2_Reading_tidying_data.html#converting-data-from-long-to-wide-format",
    "href": "vignettes/2_Reading_tidying_data.html#converting-data-from-long-to-wide-format",
    "title": "Into the Tidyverse",
    "section": "Converting data from long to wide format",
    "text": "Converting data from long to wide format\nFirst, read the annotation file called GSE60450_annotation.csv (the path to the file should be data/GSE60450_annotation.csv).\n\nannot &lt;- read_csv(\"data/GSE60450_annotation.csv\")\nhead(annot)\n\n\nOutput\n\n\n# A tibble: 6 × 3\n  ENSEMBL            Type     Annotation                     \n  &lt;chr&gt;              &lt;chr&gt;    &lt;chr&gt;                          \n1 ENSMUSG00000031805 SYMBOL   Jak3                           \n2 ENSMUSG00000031805 GENENAME Janus kinase 3                 \n3 ENSMUSG00000033909 SYMBOL   Usp36                          \n4 ENSMUSG00000033909 GENENAME ubiquitin specific peptidase 36\n5 ENSMUSG00000065524 SYMBOL   Mir135a-2                      \n6 ENSMUSG00000065524 GENENAME microRNA 135a-2                \n\n\n\nTo transform this table so that it conforms to the tidy principles, we use the pivot_wider() function.\nThis operation will convert multiple rows with type and annotation into columns containing the Symbol and Gene_name, as illustrated in the image below.\n\n\n\n\n\nThe pivot_wider() function takes two arguments:\n\nnames_from = : a name or a vector of names of column(s) containing the labels that will be transformed into the new column names.\nvalues_from = : a name or a vector of names of column(s) containing the values that will fill the new columns.\n\nIn our scenario, to reshape the annot data frame, we will use the column names Type and Annotation:\n\nannot_tidy &lt;- annot |&gt; \n  pivot_wider(names_from = Type, \n              values_from = Annotation)\n\nThe above operation changes the ‘shape’ of the dataframe from a longer format (more rows) to a wider format (more columns). While the original table consists of 40 rows, using pivot_wider() results in only 20 rows. This reduction is due to the de-duplication of rows during the creation of new columns.\n\nannot_tidy\n\n\nOutput\n\n\n# A tibble: 20 × 3\n   ENSEMBL            SYMBOL        GENENAME                                    \n   &lt;chr&gt;              &lt;chr&gt;         &lt;chr&gt;                                       \n 1 ENSMUSG00000031805 Jak3          Janus kinase 3                              \n 2 ENSMUSG00000033909 Usp36         ubiquitin specific peptidase 36             \n 3 ENSMUSG00000065524 Mir135a-2     microRNA 135a-2                             \n 4 ENSMUSG00000030374 Strn4         striatin, calmodulin binding protein 4      \n 5 ENSMUSG00000098547 Mir6921       microRNA 6921                               \n 6 ENSMUSG00000035629 Rubcn         RUN domain and cysteine-rich domain contain…\n 7 ENSMUSG00000094053 Scgb2b7       secretoglobin, family 2B, member 7          \n 8 ENSMUSG00000055491 Pprc1         peroxisome proliferative activated receptor…\n 9 ENSMUSG00000053080 Zfta          zinc finger translocation associated        \n10 ENSMUSG00000039715 Dync2i2       dynein 2 intermediate chain 2               \n11 ENSMUSG00000033475 Tomm6         translocase of outer mitochondrial membrane…\n12 ENSMUSG00000026283 Ing5          inhibitor of growth family, member 5        \n13 ENSMUSG00000037331 Larp1         La ribonucleoprotein 1, translational regul…\n14 ENSMUSG00000074489 Bglap3        bone gamma-carboxyglutamate protein 3       \n15 ENSMUSG00000038246 Fam50b        family with sequence similarity 50, member B\n16 ENSMUSG00000066189 Cacng3        calcium channel, voltage-dependent, gamma s…\n17 ENSMUSG00000005611 Irag1         inositol 1,4,5-triphosphate receptor associ…\n18 ENSMUSG00000064299 4921528I07Rik RIKEN cDNA 4921528I07 gene                  \n19 ENSMUSG00000028174 Rpe65         retinal pigment epithelium 65               \n20 ENSMUSG00000024902 Mrpl11        mitochondrial ribosomal protein L11         \n\n\n\nIt’s important to note that since we only have two distinct labels in the Type column, we are essentially replacing the existing two columns with just two new columns. Consequently, the shape of the output doesn’t technically become wider than the input data frame. However, when there are more than two unique labels in the names_from column, the output will indeed become wider compared to the input."
  },
  {
    "objectID": "vignettes/2_Reading_tidying_data.html#separating-columns",
    "href": "vignettes/2_Reading_tidying_data.html#separating-columns",
    "title": "Into the Tidyverse",
    "section": "Separating Columns",
    "text": "Separating Columns\nFirst, read the metadata file called GSE60450_metadata.csv (the path to the file should be data/GSE60450_metadata.csv).\n\nmetadata &lt;- read_csv(\"data/GSE60450_metadata.csv\")\nhead(metadata)\n\n\nOutput\n\n\n# A tibble: 6 × 2\n  gene_id    characteristics                               \n  &lt;chr&gt;      &lt;chr&gt;                                         \n1 GSM1480291 mammary gland;luminal cells;virgin            \n2 GSM1480292 mammary gland;luminal cells;virgin            \n3 GSM1480293 mammary gland;luminal cells;18.5 day pregnancy\n4 GSM1480294 mammary gland;luminal cells;18.5 day pregnancy\n5 GSM1480295 mammary gland;luminal cells;2 day lactation   \n6 GSM1480296 mammary gland;luminal cells;2 day lactation   \n\n\n\nTo transform this table so that it conforms to the tidy principles, we use the separate_wider_position()/separate_wider_delim() function. This operation will separate characteristic column into 3 separate columns containing the tissue_type, immunophenotype and development_stage, as illustrated in the image below.\n\n\n\n\n\nThe separate_wider_delim() function takes three arguments:\n\ncols = : a name or a vector of names of the column(s) that requires separation into multiple columns.\ndelim = : delimeter (or separator) between values. This is same as the delim = in read_delim().\nnames = : a vector containing column names for the the new columns.\n\nTo separate characteristic column in the metadata data frame into three separate columns based on the delimeter ; (semi colon), we can use the separate_wider_delim() function:\n\nmetadata_lform &lt;- metadata |&gt; \n  separate_wider_delim(cols = characteristics, \n                       delim =\";\",\n                       names = c(\"tissue_type\", \"immunophenotype\", \"development_stage\"))\nmetadata_lform\n\n\nOutput\n\n\n# A tibble: 12 × 4\n   gene_id    tissue_type   immunophenotype development_stage \n   &lt;chr&gt;      &lt;chr&gt;         &lt;chr&gt;           &lt;chr&gt;             \n 1 GSM1480291 mammary gland luminal cells   virgin            \n 2 GSM1480292 mammary gland luminal cells   virgin            \n 3 GSM1480293 mammary gland luminal cells   18.5 day pregnancy\n 4 GSM1480294 mammary gland luminal cells   18.5 day pregnancy\n 5 GSM1480295 mammary gland luminal cells   2 day lactation   \n 6 GSM1480296 mammary gland luminal cells   2 day lactation   \n 7 GSM1480297 mammary gland basal cells     virgin            \n 8 GSM1480298 mammary gland basal cells     virgin            \n 9 GSM1480299 mammary gland basal cells     18.5 day pregnancy\n10 GSM1480300 mammary gland basal cells     18.5 day pregnancy\n11 GSM1480301 mammary gland basal cells     2 day lactation   \n12 GSM1480302 mammary gland basal cells     2 day lactation   \n\n\n\nThe separate_wider_position() function splits at fixed widths and takes two arguments:\n\ncols = : a name or a vector of names of the column(s) that requires separation into multiple columns.\nwidths = : a named vector containing numbers where the names become the new column names and values specify the column widths.\n\nFor instance, we can divide the gene_id column into three separate columns to evaluate the functionality of this operation (this is provided purely as an example):\n\nmetadata_lform |&gt; \n  separate_wider_position(cols = gene_id, \n                          widths = c(code = 3, prefix = 4, id = 3))\n\n\nOutput\n\n\n# A tibble: 12 × 6\n   code  prefix id    tissue_type   immunophenotype development_stage \n   &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;         &lt;chr&gt;           &lt;chr&gt;             \n 1 GSM   1480   291   mammary gland luminal cells   virgin            \n 2 GSM   1480   292   mammary gland luminal cells   virgin            \n 3 GSM   1480   293   mammary gland luminal cells   18.5 day pregnancy\n 4 GSM   1480   294   mammary gland luminal cells   18.5 day pregnancy\n 5 GSM   1480   295   mammary gland luminal cells   2 day lactation   \n 6 GSM   1480   296   mammary gland luminal cells   2 day lactation   \n 7 GSM   1480   297   mammary gland basal cells     virgin            \n 8 GSM   1480   298   mammary gland basal cells     virgin            \n 9 GSM   1480   299   mammary gland basal cells     18.5 day pregnancy\n10 GSM   1480   300   mammary gland basal cells     18.5 day pregnancy\n11 GSM   1480   301   mammary gland basal cells     2 day lactation   \n12 GSM   1480   302   mammary gland basal cells     2 day lactation"
  },
  {
    "objectID": "vignettes/2_Reading_tidying_data.html#uniting-columns",
    "href": "vignettes/2_Reading_tidying_data.html#uniting-columns",
    "title": "Into the Tidyverse",
    "section": "Uniting Columns",
    "text": "Uniting Columns\nThe unite() function is the complement of separate(). Therefore, let’s revert what we did in the previous section to combine multiple columns to a single column as illustrated in the image below.\n\n\n\n\n\nThe unite() function takes three arguments:\n\ncol = : name of the new column that will contain the united values.\n… = : a vector containing column names to unite.\nsep = : delimeter (or separator) this is same as the delim = in read_delim(). If we don’t specify a separator to insert between the combined values, they will be separated by _ (underscores).\n\nTo separate characteristic column in the metadata data frame into three separate columns:\n\nmetadata_lform |&gt; \n  unite(col = characteristics, \n        tissue_type, immunophenotype, development_stage,\n        sep = \",\")\n\n\nOutput\n\n\n# A tibble: 12 × 2\n   gene_id    characteristics                               \n   &lt;chr&gt;      &lt;chr&gt;                                         \n 1 GSM1480291 mammary gland,luminal cells,virgin            \n 2 GSM1480292 mammary gland,luminal cells,virgin            \n 3 GSM1480293 mammary gland,luminal cells,18.5 day pregnancy\n 4 GSM1480294 mammary gland,luminal cells,18.5 day pregnancy\n 5 GSM1480295 mammary gland,luminal cells,2 day lactation   \n 6 GSM1480296 mammary gland,luminal cells,2 day lactation   \n 7 GSM1480297 mammary gland,basal cells,virgin              \n 8 GSM1480298 mammary gland,basal cells,virgin              \n 9 GSM1480299 mammary gland,basal cells,18.5 day pregnancy  \n10 GSM1480300 mammary gland,basal cells,18.5 day pregnancy  \n11 GSM1480301 mammary gland,basal cells,2 day lactation     \n12 GSM1480302 mammary gland,basal cells,2 day lactation"
  },
  {
    "objectID": "vignettes/2_Reading_tidying_data.html#missing-values",
    "href": "vignettes/2_Reading_tidying_data.html#missing-values",
    "title": "Into the Tidyverse",
    "section": "Missing Values",
    "text": "Missing Values\nA value can be missing in one of two possible ways:\n\nExplicitly, meaning it is flagged with NA.\nImplicitly, implying that it is just not present in the data.\n\nLet’s illustrate this idea with a very simple data frame:\n\ncovid_vac &lt;- data.frame(\n    year = c(2020, 2020, 2021, 2021, 2021,  2023, 2023,\n             2023, 2024, 2024), \n    vaccine_type = c(\"Pfizer\", \"Moderna\", \"Pfizer\", \"Moderna\", \"Novavax\", \n                   \"Pfizer\", \"Moderna\", \n                  \"Novavax\", \"Moderna\", NA),\n    count = c(0, 3, 63, 88, 51,\n               38, 19,\n              5, 9, 7)\n)\ncovid_vac\n\n\nOutput\n\n\n   year vaccine_type count\n1  2020       Pfizer     0\n2  2020      Moderna     3\n3  2021       Pfizer    63\n4  2021      Moderna    88\n5  2021      Novavax    51\n6  2023       Pfizer    38\n7  2023      Moderna    19\n8  2023      Novavax     5\n9  2024      Moderna     9\n10 2024         &lt;NA&gt;     7\n\n\n\nIn this dataset, we identify two occurrences of missing values:\n\nThe vaccine_type in 2024 with a count of 7 is explicitly missing, denoted by the presence of NA in the cell where its value should be.\nThe counts for the Novavax vaccine in 2020 and Pfizer, Novavax vaccines in 2024, are implicitly missing, as they do not appear in the dataset at all.\n\n\nis.na()\nTo identify missing values we can use is.na() function which returns a logical vector with TRUE in the element locations that contain missing values represented by NA.\n\nis.na(covid_vac)\n\n\nOutput\n\n\n       year vaccine_type count\n [1,] FALSE        FALSE FALSE\n [2,] FALSE        FALSE FALSE\n [3,] FALSE        FALSE FALSE\n [4,] FALSE        FALSE FALSE\n [5,] FALSE        FALSE FALSE\n [6,] FALSE        FALSE FALSE\n [7,] FALSE        FALSE FALSE\n [8,] FALSE        FALSE FALSE\n [9,] FALSE        FALSE FALSE\n[10,] FALSE         TRUE FALSE\n\n\n\n\nis.na(covid_vac$vaccine_type)\n\n\nOutput\n\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n\n\n\nTo identify the location or the number of NAs we can use the which() and sum() functions:\n\nwhich(is.na(covid_vac))\nsum(is.na(covid_vac))\n\n\nOutput\n\n\n[1] 20\n\n\n[1] 1\n\n\n\n\n\nna.omit()\nTo omit all rows containing missing values, we can use na.omit() function in base R:\n\nna.omit(covid_vac)\n\n\nOutput\n\n\n  year vaccine_type count\n1 2020       Pfizer     0\n2 2020      Moderna     3\n3 2021       Pfizer    63\n4 2021      Moderna    88\n5 2021      Novavax    51\n6 2023       Pfizer    38\n7 2023      Moderna    19\n8 2023      Novavax     5\n9 2024      Moderna     9\n\n\n\n\n\ncomplete()\nWe can use the complete() function to make our dataset more complete or to make missing values explicit in tidy data:\n\ncovid_vac |&gt; complete(year, vaccine_type)\n\n\nOutput\n\n\n# A tibble: 16 × 3\n    year vaccine_type count\n   &lt;dbl&gt; &lt;chr&gt;        &lt;dbl&gt;\n 1  2020 Moderna          3\n 2  2020 Novavax         NA\n 3  2020 Pfizer           0\n 4  2020 &lt;NA&gt;            NA\n 5  2021 Moderna         88\n 6  2021 Novavax         51\n 7  2021 Pfizer          63\n 8  2021 &lt;NA&gt;            NA\n 9  2023 Moderna         19\n10  2023 Novavax          5\n11  2023 Pfizer          38\n12  2023 &lt;NA&gt;            NA\n13  2024 Moderna          9\n14  2024 Novavax         NA\n15  2024 Pfizer          NA\n16  2024 &lt;NA&gt;             7\n\n\n\nThis function add missing values for potential combinations of year and vaccine_type. One problem is that R assumes NA in status as one of the combinations. To fix this, we can specify the labels of status to be considered as follows:\n\ncovid_vac |&gt; complete(year, vaccine_type = c(\"Pfizer\", \"Moderna\", \"Novavax\"))\n\n\nOutput\n\n\n# A tibble: 13 × 3\n    year vaccine_type count\n   &lt;dbl&gt; &lt;chr&gt;        &lt;dbl&gt;\n 1  2020 Moderna          3\n 2  2020 Novavax         NA\n 3  2020 Pfizer           0\n 4  2021 Moderna         88\n 5  2021 Novavax         51\n 6  2021 Pfizer          63\n 7  2023 Moderna         19\n 8  2023 Novavax          5\n 9  2023 Pfizer          38\n10  2024 Moderna          9\n11  2024 Novavax         NA\n12  2024 Pfizer          NA\n13  2024 &lt;NA&gt;             7\n\n\n\nWe can use the fill argument to assign the fill value:\n\ncovid_vac |&gt; complete(year, \n                      vaccine_type = c(\"Pfizer\", \"Moderna\", \"Novavax\"),\n                       fill = list(count = 0))\n\n\nOutput\n\n\n# A tibble: 13 × 3\n    year vaccine_type count\n   &lt;dbl&gt; &lt;chr&gt;        &lt;dbl&gt;\n 1  2020 Moderna          3\n 2  2020 Novavax          0\n 3  2020 Pfizer           0\n 4  2021 Moderna         88\n 5  2021 Novavax         51\n 6  2021 Pfizer          63\n 7  2023 Moderna         19\n 8  2023 Novavax          5\n 9  2023 Pfizer          38\n10  2024 Moderna          9\n11  2024 Novavax          0\n12  2024 Pfizer           0\n13  2024 &lt;NA&gt;             7\n\n\n\nWe can use the full_seq() function from tidyr to fill out the data frame with all years from 2020 to 2024 and assign vaccination types and count values of 0 to those years and for which there was no observation.\n\ncovid_vac |&gt; complete(year = full_seq(year, period = 1), \n                      vaccine_type = c(\"Pfizer\", \"Moderna\", \"Novavax\"),\n                       fill = list(count = 0))\n\n\nOutput\n\n\n# A tibble: 16 × 3\n    year vaccine_type count\n   &lt;dbl&gt; &lt;chr&gt;        &lt;dbl&gt;\n 1  2020 Moderna          3\n 2  2020 Novavax          0\n 3  2020 Pfizer           0\n 4  2021 Moderna         88\n 5  2021 Novavax         51\n 6  2021 Pfizer          63\n 7  2022 Moderna          0\n 8  2022 Novavax          0\n 9  2022 Pfizer           0\n10  2023 Moderna         19\n11  2023 Novavax          5\n12  2023 Pfizer          38\n13  2024 Moderna          9\n14  2024 Novavax          0\n15  2024 Pfizer           0\n16  2024 &lt;NA&gt;             7\n\n\n\n\n\nfill()\nThe fill() function is used to fill missing values in a data frame, particularly within columns.\nLet’s first make missing values in the covid_vac dataset explicit and assign it to a data frame named covid_vac_comp.\n\ncovid_vac_comp &lt;-  covid_vac |&gt; \n  complete(year = full_seq(year, period = 1), \n           vaccine_type = c(\"Pfizer\", \"Moderna\", \"Novavax\"))\n\nWe can specify the direction to fill the missing values using the argument .direction. Remember to specify the list of columns to fill.\n\ncovid_vac_comp |&gt; fill(count, .direction = \"down\")\n\n\nOutput\n\n\n# A tibble: 16 × 3\n    year vaccine_type count\n   &lt;dbl&gt; &lt;chr&gt;        &lt;dbl&gt;\n 1  2020 Moderna          3\n 2  2020 Novavax          3\n 3  2020 Pfizer           0\n 4  2021 Moderna         88\n 5  2021 Novavax         51\n 6  2021 Pfizer          63\n 7  2022 Moderna         63\n 8  2022 Novavax         63\n 9  2022 Pfizer          63\n10  2023 Moderna         19\n11  2023 Novavax          5\n12  2023 Pfizer          38\n13  2024 Moderna          9\n14  2024 Novavax          9\n15  2024 Pfizer           9\n16  2024 &lt;NA&gt;             7\n\n\n\nSimilarly, we can fill upwards as follows:\n\ncovid_vac_comp |&gt; fill(count, .direction = \"up\")\n\n\nOutput\n\n\n# A tibble: 16 × 3\n    year vaccine_type count\n   &lt;dbl&gt; &lt;chr&gt;        &lt;dbl&gt;\n 1  2020 Moderna          3\n 2  2020 Novavax          0\n 3  2020 Pfizer           0\n 4  2021 Moderna         88\n 5  2021 Novavax         51\n 6  2021 Pfizer          63\n 7  2022 Moderna         19\n 8  2022 Novavax         19\n 9  2022 Pfizer          19\n10  2023 Moderna         19\n11  2023 Novavax          5\n12  2023 Pfizer          38\n13  2024 Moderna          9\n14  2024 Novavax          7\n15  2024 Pfizer           7\n16  2024 &lt;NA&gt;             7\n\n\n\nOnce the data is structured and organized according to tidy principles, we can begin manipulating and transforming it. The next section illustrates how this can be accomplished using the dplyr package from the tidyverse package suit."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to R: Exploring the tidyverse",
    "section": "",
    "text": "This workshop is designed to provide beginners with foundational understanding of R programming language. Through a combination of theoretical explanations, hands-on coding exercises, and practical applications, participants will learn how to leverage R for data analysis, manipulation and visualization cancer biology datasets.\nThe workshop will cover essential programming concepts and gradually introduce more advanced topics, with a focus on using the tidyverse package suite for efficient data handling, analysis and visualization. The aim of this workshop is to improve the reproducibility and efficiency of scientific research by teaching powerful tools in data analysis and creating informative plots."
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "Introduction to R: Exploring the tidyverse",
    "section": "",
    "text": "This workshop is designed to provide beginners with foundational understanding of R programming language. Through a combination of theoretical explanations, hands-on coding exercises, and practical applications, participants will learn how to leverage R for data analysis, manipulation and visualization cancer biology datasets.\nThe workshop will cover essential programming concepts and gradually introduce more advanced topics, with a focus on using the tidyverse package suite for efficient data handling, analysis and visualization. The aim of this workshop is to improve the reproducibility and efficiency of scientific research by teaching powerful tools in data analysis and creating informative plots."
  },
  {
    "objectID": "index.html#learning-objectives",
    "href": "index.html#learning-objectives",
    "title": "Introduction to R: Exploring the tidyverse",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nParticipants will gain the following skills:\n\nProficiency in using R and RStudio for data analysis.\nBasic R programming skills.\nReading, tidying, and joining datasets using readr and tidyr packages.\nData manipulation and transformation using dplyr package.\nCreating various types of plots using ggplot2 package."
  },
  {
    "objectID": "index.html#prerequisites",
    "href": "index.html#prerequisites",
    "title": "Introduction to R: Exploring the tidyverse",
    "section": "Prerequisites",
    "text": "Prerequisites\nBefore starting this course you will need to ensure that your computer is set up with the required software. If you have any difficulty installing any of this software then please contact one of the trainers for help.\n\nInstalling R and RStudio\nR and RStudio are separate downloads and installations.\nR is the underlying statistical computing environment. The base R system and a very large collection of packages that give you access to a huge range of statistical and analytical functionality are available from CRAN, the Comprehensive R Archive Network.\nHowever, using R alone is no fun. RStudio is a graphical integrated development environment (IDE) that makes using R much easier and more interactive.\n\nOption 1: Local Installation\nYou need to install R before you install RStudio.\n\n\nWindows\n\n\nIf you already have R and RStudio installed:\n\nOpen RStudio, and click on “Help” &gt; “Check for updates”. If a new version is available, quit RStudio, and download the latest version for RStudio.\nTo check which version of R you are using, start RStudio and the first thing that appears in the console indicates the version of R you are running. Alternatively, you can type sessionInfo(), which will also display which version of R you are running. Go on the CRAN website and check whether a more recent version is available. If so, please download and install it. You can check here for more information on how to remove old versions from your system if you wish to do so.\n\nIf you don’t have R and RStudio installed:\n\nDownload R from the CRAN website.\nRun the .exe file that was just downloaded\nGo to the RStudio download page\nUnder Installers select RStudio x.yy.zzz - Windows 10/8/7 where x, y, and z represent version numbers)\nDouble click the file to install it\nOnce it’s installed, open RStudio to make sure it works and you don’t get any error messages.\n\n\n\n\nmacOS\n\nIf you already have R and RStudio installed:\n\nOpen RStudio, and click on “Help” &gt; “Check for updates”. If a new version is available, quit RStudio, and download the latest version for RStudio.\nTo check the version of R you are using, start RStudio and the first thing that appears on the terminal indicates the version of R you are running. Alternatively, you can type sessionInfo(), which will also display which version of R you are running. Go on the CRAN website and check whether a more recent version is available. If so, please download and install it.\n\nIf you don’t have R and RStudio installed:\n\nDownload R from the CRAN website.\nSelect the .pkg file for the latest R version\nDouble click on the downloaded file to install R\nIt is also a good idea to install XQuartz (needed by some packages)\nGo to the RStudio download page\nUnder Installers select RStudio x.yy.zzz - Mac OS X 10.6+ (64-bit) (where x, y, and z represent version numbers)\nDouble click the file to install RStudio\nOnce it’s installed, open RStudio to make sure it works and you don’t get any error messages.\n\n\n\n\n\nLinux\n\n\nFollow the instructions for your distribution from CRAN, they provide information to get the most recent version of R for common distributions. For most distributions, you could use your package manager (e.g., for Debian/Ubuntu run sudo apt-get install r-base, and for Fedora sudo yum install R), but we don’t recommend this approach as the versions provided by this are usually out of date. In any case, make sure you have at least R 4.3.2.\nGo to the RStudio download page\nUnder Installers select the version that matches your distribution, and install it with your preferred method (e.g., with Debian/Ubuntu sudo dpkg -i   rstudio-x.yy.zzz-amd64.deb at the terminal).\nOnce it’s installed, open RStudio to make sure it works and you don’t get any error messages.\n\n\n\n\nOption 2: Using Open On Demand on Peter Mac Cluster\n\n\nRequesting Access to Peter Mac Cluster\n\nTo request access to the Cluster\n\nLogin to SNOW and create an IT Service Desk Request as shown here.\nComplete the required fields, including the following information.\n\n\nRequest Item: (Other)\nService: Research Computing Cluster\nSubject: HPC Cluster Account for $first_name $last_name\nDescription: Please include the name of the person who needs the account, their lab group, their manager or supervisor and what experience they have with using a HPC cluster (e.g. none, some, experienced).\n\n\n\n\nUsing Open On Demand\n\nOpen OnDemand is a web portal that provides access to PeterMac file systems and cluster resources. It allows to view, edit, upload and download files, create, edit, submit and monitor jobs, run GUI applications, and connect via SSH, all via a web browser and with a minimal knowledge of Linux and scheduler commands. It enables running RStudio on the cluster giving you access to more memory than with our RStudio Pro server. Future work will enable it to use Jupyter notebooks on the cluster.\nHow to login\nRequirements:\n\nMust have a cluster account.\nIf want to use remotely:\n\nMust have remote access to Citrix or VPN.\nWith Citrix must use Peter Mac Virtual Desktop and the Firefox inside that.\n\nUsername: your short cluster username not your Peter Mac computer username (i.e., first_letter_of_first_namelast_name ex: srajapaksa NOT last_namefirst_name ex: rajapaksasandun)\nPassword: Peter Mac cluster password.\n\nIn a browser navigate to https://research-cluster.petermac.org.au and enter your login, as in:\n\n\n\n\n\nIf you see the following Unauthorized error instead of the login prompt, you will need to use the Citrix Edge Browser.\n\n\n\n\n\nYou should then see in the Open OnDemand Dashboard as in:\n\n\n\n\n\n\n\n\n\nInstalling R Packages\nOn this course we will be making use of a brilliant collection of packages designed for data science called the tidyverse that make it much easier and more fun to work with your data. After installing R and RStudio, follow the instructions below to install the tidyverse package suite.\n\nAfter starting RStudio, at the console type: install.packages(\"tidyverse\") (look for the ‘Console’ tab and type at the &gt; prompt)\nYou can also do this by going to Tools -&gt; Install Packages and typing the names of the packages separated by a comma."
  },
  {
    "objectID": "index.html#data",
    "href": "index.html#data",
    "title": "Introduction to R: Exploring the tidyverse",
    "section": "Data",
    "text": "Data\nThe Metabric study characterized the genomic mutations and gene expression profiles for 2509 primary breast tumours. In addition to the gene expression data generated using microarrays, genome-wide copy number profiles were obtained using SNP microarrays. Targeted sequencing was performed for 2509 primary breast tumours, along with 548 matched normals, using a panel of 173 of the most frequently mutated breast cancer genes as part of the Metabric study.\nRefrences:\n\nCurtis et al., Nature 486:346-52, 2012\nPereira et al., Nature Communications 7:11479, 2016\n\nBoth the clinical data and the gene expression values were downloaded from cBioPortal.\nWe excluded observations for patient tumor samples lacking expression data, resulting in a data set with fewer rows."
  },
  {
    "objectID": "index.html#into-the-tidyverse",
    "href": "index.html#into-the-tidyverse",
    "title": "Introduction to R: Exploring the tidyverse",
    "section": "Into the tidyverse",
    "text": "Into the tidyverse\nThe core tidyverse includes the packages that you’re likely to use in everyday data analyses. Therefore, this workshop offers an introduction to these core packages. As of tidyverse 1.3.0, the following packages are included in the core tidyverse:\n\n\n\n\n\n\n\nFigure 1: Hex logos for the eight core tidyverse packages and their primary purposes. Image source:https://education.rstudio.com/blog/2020/07/teaching-the-tidyverse-in-2020-part-1-getting-started/\n\n\n\nggplot2: Grammar of Graphics. Enables the creation of graphics in a declarative manner.\ndplyr: Grammar for data manipulation. Presents a set of verbs to address common challenges in data manipulation.\ntidyr: Provides a collection of functions for achieving tidy data.\nreadr: Facilitates the rapid and user-friendly reading of rectangular data (e.g., csv, tsv, and fwf).\npurrr: Functional programming toolkit. Offers a set of tools for efficient work with functions and vectors.\ntibble: Tibbles, a modern re-imagining of the data frame, offering a more user-friendly and efficient approach to handling tabular data.\nstringr: Provides a set of functions designed to simplify and enhance string manipulations.\nforcats: Provides a suite of useful tools for handling and manipulating categorical variables (factors)."
  },
  {
    "objectID": "index.html#credits-and-acknowledgement",
    "href": "index.html#credits-and-acknowledgement",
    "title": "Introduction to R: Exploring the tidyverse",
    "section": "Credits and Acknowledgement",
    "text": "Credits and Acknowledgement\nThese content were adapted from the following course materials:\n\nR for Data Science book\nOHI Data Science Training\nData Carpentry\nWEHI tidyr coursebook by Brendan R. E. Ansell\ncontent developed by Maria Doyle."
  }
]